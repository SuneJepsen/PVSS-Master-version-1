In this section we look at the electronic voting protocol described in \cite{Schoenmakers1999}. The protocol is based on the PVSS protocol described in the same article. We will only describe the electronic voting protocol but as doing so, the relevant elements from the PVSS protocol will be taking into the description. For the rest of this chapter we will be referring to the electronic voting protocol, as simply the protocol, unless specified otherwise. \\

\noindent
Giving the complexity of the protocol we divided this description into three parts. In the first part we will describe the protocol as simple as possible, leaving out mathematical justification and proofs. In second part we will be looking at the mathematical justification, describing this in the same order as in the first part. Finally we will look though the proofs in the last part. 


\section{The protocol}

\noindent
The overall concept of the protocol is to allow a group of voters to cast there votes in the form "yes" or "no", and publish the result to a public Bulletinboard. When a deadline is reach or when all votes have been casted a group of talliers takes the votes and calculates the end result. 
Using MPC and PVSS protocols this is done in such a way that none other then the voter knows the value of his vote, but everyone can validates the correctness and consistence of the vote. Below we present a simple overview showing the progress of the protocol. \\

\noindent
\textbf{Short overview of the protocol}
The protocol is divided into three main parts, each part representing a different phase in the election, roughly put one can say pre-election, the election and post-election. 

\noindent
\begin{enumerate}
    \item \textbf{Initialization}
    This represents the pre-election phase where the preparation for the actually election happens. Here the requirements for the election is demented and the different authorities is registered. 
    
        \begin{enumerate}
            \item The system publishes the system parameters and the security requirements. In our implementation an admin user will log into the system and start the election. The admin will choose the security parameter and the amount of required talliers. Last he will initiate the computation of the system parameters.
            
            \item Each tallier generates a private and a public key.
            
            \item Each tallier registries their public keys on the Bulletinboard.
            
            \item Each voter signs it credentials on the Bulletinboard.
        \end{enumerate}
        
    \item \textbf{Ballot casting}
    This represent the actually election, where the registered voters castes there votes and publish the result to the Bulletinboard. 
    
        \begin{enumerate}
            \item Each voter votes $1$ or $0$
        
            \item Each voter generates a random secret.
        
            \item Each voter creates shares of the secret to each tallier and encrypts it with the corresponding public key of the tallier. Each voter supply this secret share with evidence of its consistency with a $DLEQ$ proof.
        
            \item Each voter supply evidence for a valid vote with $PROOF_U$.
        \end{enumerate}
        
    \item \textbf{Tallying} 
    This represents the post-election phase where the Tallying authorities, which where registered in Initialization, counts the votes together and publish the result to the Bulletinboard.
    
        \begin{enumerate}
            \item At least $t$ tallier accumulates and decrypts their shares.
            
            \item One authority completes the final computation of the total votes.
        \end{enumerate}
\end{enumerate}


\noindent
In the following we will describe the central parts of the protocol, leaving out the complexity of mathematical justification and proofs. The idea is to get an understanding of how the protocol works without know exactly why it works. \\

\noindent
For efficiency we will limit the computation of the votes to a finite number of talliers. There are \textit{m} voters and \textit{n} talliers. 
%--------------------------------------------------------------------------
\subsection{Initialization}   \label{sec:the_protocol_initialization}
%--------------------------------------------------------------------------

\noindent
\textbf{The bulletin board publishes all system parameters which is the public elements a prime $q$,  the generators $g$ and $G$ and a security parameter $t$.}


\begin{alignat*}{2}
q \ &\in_R \{2^{l-1},...,2^{l}\}, \ where\  l &&> 1024 \\
f \ &\in_R \{2,...,2q-1\} \rightarrow g &&= f^2 \ mod\ 2q+1  \\
F \ &\in_R \{2,...,2q-1\}\rightarrow G &&= F^2 \ mod\ 2q+1 \\
t &\in \Z_q^* &&= \{1,2,3,...,q-1\} 
\end{alignat*}

\noindent
The prime $q$ is uniformly randomly chosen from $\Z$, but in practise we use the subset $2^{l-1}$ to $2^l$. $l$ is chosen  larger then 1024 because of the security requirements described in section \ref{sec:Solving_the_Discrete_Logarithm_Problem}. The generators $g$ and $G$ are computed as squares from the sets $f$ and $F$, the reason for this is elaborated in section \ref{sec:protocol_details_initialization}.  $2q+1$ must also be a prime and the reason why we use $2q +1$ is because we are working with Shamirs scheme in the exponents which also is described in section \ref{sec:protocol_details_initialization}. $t$ is chosen based on the system requirements for our fault tolerance against corrupted parties.\\

\noindent
\textbf{The tallier generates a private key $x_i$ and a public key $y_i$.}
\begin{flalign*}
Private \ key &: x_{i} \in_R \Z_q^* = \{1,2,3,...,q-1\}\\
Public \ key &: y_i=G^{x_i} ,\ i \in \{1,2,3,...., n \}
\end{flalign*}

\noindent
Every tallier generates a uniformly randomly chosen private key from $\Z_q^*$ where $q$ is a prime. The star notation refers to a set with none greatest common divisor larger then $1$ respectively with $q$, which is described in section \ref{sec:group_theory}. The public key is computed on an exponentation on $G$, which essentially gives us the security of the discrete logarithm problem described in section ~\ref{sec:discrete_logarithm_problem}.

%--------------------------------------------------------------------------
\subsection{Ballot casting}
\label{sec:ballot_casting}
%--------------------------------------------------------------------------
The  Ballot casting consists of \textit{distribution of the shares} and \textit{verification of the shares}.\\

\noindent
First the voter either votes "no" or "yes" corresponding to 0 or 1. The voter select a uniformly random secret $s \in \Z_q$. The PVSS protocol is then used to distribute shares which contain a combination of the secret $s$ and the vote. Every voter will construct a random polynomial at degree $t-1$ and then evaluate the shares  to each of the talliers.\\


\noindent
\textbf{The voter casts his vote, either 0 or 1. Creates a random secret $s$ and a random polynomial of degree at most $t-1$ and computes the shares.}

\begin{flalign*}
Vote &: v\in\{0,1\} & \\
Random \ secret  &: s\in_R \Z_q &\\
Random \ polynomium &:  p(x)=s+\alpha_1x^1+\alpha_2x^2+,...,+\alpha_{t-1}x^{t-1}, \ \alpha_j\in_R \Z_q &\\
Secret \ Shares &:  p(0)=s,\ p(1),\ p(2),...,\ p(n)
\end{flalign*}

\noindent
The degree of the polynomium is based on the security parameter $t$ described in section ~\ref{sec:the_protocol_initialization}. Each voter chooses uniformly random the coefficients $\alpha$ in $Z_q$ and a random secret $s$ and computes the shares using Shamirs secret sharing which is described in section \ref{sec:example_computation_using_shamir_secret_sharing}.\\

\noindent
\textbf{The voter distributes the encrypted share and creates the proofs $PROOF_U$ and $DLEQ$.}

\begin{alignat*}{2}
Encryption \ of \ the \ share : Y_i&=y_i^{p(i)} ,1\leq i\leq n \\ 
Hidden \ vote : U&=G^{s+v}
\end{alignat*}

\noindent
$p(i)$ refers to the share in a point corresponding to a given tallier. The shares are encrypted using the talliers public key $y_i$. $U$ is a DL problem that hides the vote as the exponentiation. As the vote $v$ only can hold the values $0$ or $1$ this wouldn't make for a hard problem. By reusing the secret $s$ and adding this to $v$, then given a large $s$, $U$ should be a hard problem. The above is then published to the Bulletinboard. \\

\noindent
Besides the above, the proofs $PROOF_U$ and $DLEQ$ are computed and published. $PROOF_U$ proofs that the vote is either $0$ or $1$ without revealing the actual value of the vote. The $DLEQ$ proofs that the shares are constructed correctly and consistent. Both proofs are elaborated in details later in section \ref{sec:proofs}

%--------------------------------------------------------------------------
\subsection{Tallying}
\label{sec:tallying}
%--------------------------------------------------------------------------
Tallying is the process of counting the votes. Here the tallier uses their private keys to collectively compute the final tally, based on the valid ballots.\\



\noindent
\textbf{The tallier decrypts the shares and publishes a $DLEQ$ proof}

\begin{flalign*}
Multiplum \ of \ encrypted \ shares &: Y_i^*=(\prod\limits_{j=1}^{m} Y_{ij}) \ (mod\ 2 \cdot q+1)
\end{flalign*}

\noindent
The homomorphic secret sharing property ensures that each tallier will  be able to multiply the shares and then decrypt. Let $Y_{ij}$ be the value $Y_i$ computed by the $j$-th voter, which is the encrypted share,  as described in the previous section. This means that the $i$ is referring to tallier 1, tallier  2 and tallier 3 etc. and $j$ is referring to voter 1, voter 2 and voter 3 etc. $Y_i^*$ is then the multiplum of encrypted shares for a given tally $i$. Tally $i$ is now able to decrypt the multiplum $Y_i^*$ using his private key $x_i$. 

\begin{flalign*}
Decrypted \ multiplum \ of \ shares &: S_i^*=(Y_{i}^*)^{\frac{1}{x_i}} \ (mod\ 2 \cdot q+1)
\end{flalign*}

\noindent
$S_i^*$ is the decrypted multiplum of all tally $i$ shares. As this is the multiplum of shares then no information of the individual share is revealed and tally $i$ can safely publish the decrypted result to the Bulletinboard.

\noindent
Note that besides decrypting the shares the tallier will publish a $DLEQ$ proof which shows that the decrypting was done correct. See figure \ref{fig:DLEQ_by_talliers} of the $DLEQ$ proof. Also note that we need to computing the inverse of the key $x_i$. To compute the inverse we can use Extended Euclidean algorithm described in section \ref{sec:modular_arithmetic}.\\


\noindent
\textbf{A master authority applies Lagrange interpolation}\\
With all the $S^*$ we can compute the sum of the secrets.   One can now use lambda, which is computed from the  Lagrange interpolation formular, \begin{math} \lambda_j \end{math} and multiply these values which will be the same as the sum of the exponents. See figure \ref{info:Computing_the_coefficients} \\

\noindent
The \begin{math}p_j(0) \end{math} correspond to the sum of the secret values of \textit{s} for the voters. This \begin{math}p_j(0)\end{math} corresponds to the evaluation of \begin{math}h(0)\end{math}. See figure  \ref{info:Applying_Lagrange_polynomial_interpolation}


\begin{alignat*}{2}
(Y_1^*)^{\lambda_1  \cdot  \ (mod \ q)}  \cdot  (Y_2^*)^{\lambda_2 \ (mod \ q)}  \cdot  (Y_n^*)^{\lambda_n \ (mod \ q)} \ (mod \ 2 \cdot q+1)
\end{alignat*}


\noindent
We can substitute the $Y^*$ with $G$. The final result in the exponents is a evaluation in some polynomium in $0$ which corresponds to the sum of all random values $s$.

\begin{alignat*}{2}
&=G^{ \sum\limits_{j=1}^m \lambda_j p_j(1)} \cdot G^{ \sum\limits_{j=1}^m \lambda_j p_j(2)} \cdot...\cdot G^{ \sum\limits_{j=1}^m \lambda_j p_j(n)}\\
&=G^{ \sum\limits_{j=1}^m \lambda_j p_j(1) +  \sum\limits_{j=1}^m \lambda_j p_j(2) +...+  \sum\limits_{j=1}^m \lambda_j p_j(n)}\\
&=G^{ \sum\limits_{j=1}^m (\lambda_j p_j(1)+\lambda_j p_j(2)+,...,+\lambda_{j}p_j(n))} = G^{ \sum\limits_{j=1}^m p_j(0)}= G^{ \sum\limits_{j=1}^m s_j}
\end{alignat*}


\noindent
\textbf{A master authority computes the votes}\\
The last step is to isolate the votes and then compute the final result. By combining \begin{math}U_j \end{math} we obtain the following.

\begin{alignat*}{2}
(\prod\limits_{j=1}^{m} U_{j}) \ (mod \ 2 \cdot q+1)=  G^{ \sum\limits_{j=1}^m s_j +v_j}
\end{alignat*}

\noindent
By dividing with $G^{ \sum\limits_{j=1}^m s_j}$ we isolate \textit{v}

\begin{alignat*}{2}
\frac{G^{ \sum\limits_{j=1}^m s_j +v_j}}{{ G^{ \sum\limits_{j=1}^m s_j} }} =G^{ \sum\limits_{j=1}^m s_j +v_j -\sum\limits_{j=1}^m s_j} = G^{ \sum\limits_{j=1}^m v_j}
\end{alignat*}

\noindent
To solve the computing of the votes one can compute \begin{math}G^0, G^1, G^3,..., G^{v_j} \end{math} by exhaustive search. A more efficient algorithm is to use Baby-step giant-step algorithm. 

%--------------------------------------------------------------------------
\section{Protocol details} \label{sec:protocol_details}
%--------------------------------------------------------------------------

\subsection{Initialization} \label{sec:protocol_details_initialization}
\noindent
In our implementation we will pick a prime, \begin{math}q\end{math}, so we avoid doing the gcd computation. The protocol states that we have to compute in a group of order q. This means that when we are doing operations in the exponent this property should be satisfied \begin{math}g^q=1\end{math} where \begin{math}q\end{math} is prime. If we are doing \begin{math}mod \ q \end{math} in the exponent we have \begin{math}g^q=g^0\end{math}. The reason for doing operation in the exponent \begin{math}mod \ q\end{math} is because we are using Sharmir secret sharing which require a finite field.\\

\noindent
One can see that given a generator $g=2 $ and a prime $q=5$, then \begin{math}2^5 \ mod \ 5 = 32 \ mod \ 5 = 2\end{math}. For this to be true, we take the square of numbers modulo a prime in this form \begin{math}2q+1\end{math}. This is also called a strong prime. By using this mathematical structure this property holds. We can choose \begin{math}b=a^2\end{math}. Then we see the property holds \begin{math}b^{q} = 1 \ mod \ 2q+1\end{math}. Using the same values as before, it is clear that \begin{math}(2^2)^5 \ mod \ 11 = 1024 \ mod \ 11 = 1\end{math}. Fermat little theorem states that \begin{math}b^{q-1} \ mod \ q = 1\end{math} where \begin{math}q\end{math} is prime. So we know if we pick our \begin{math}q\end{math} and \begin{math}b\end{math} (as a square)  in this form \begin{math}(a^{2})^{q+1-1} \ mod \ 2q+1 =1 =  a^{2q} \ mod \ 2q+1 =1\end{math} the property holds.\\

\noindent
The generators is randomly chosen in the set between $2$ and $2q-1$.  We remove $1$ because if $1$ get squared it will always gives $1$ and can therefor not be used as a generator. We remove $2q$ because $(2q)^2 = 1 \ mod \ 2q+1$. That means if you square $2q$ it will also give $1$ and can therefor not be used as a generator.

\subsection{Ballot casting}

\textbf{Elaboration of computation of  $Y_i$}\\
The $Y_i$ is the shares encrypted using the talliers public key $y_i$ as described in section \ref{sec:ballot_casting}.
 
\begin{alignat*}{5}
&Voter \ 1&: Y_{1,1}&&=y_{1,1}^{p_1(1)},Y_{2,1}&&=y_{2,1}^{p_2(2)} ,.., Y_{n,1}&&=y_n^{p_n(n)}\\
&Voter \ 2&: Y_{1,2}&&=y_{1,2}^{p_1(1)},Y_{2,2}&&=y_{2,2}^{p_2(2)} ,.., Y_{n,2}&&=y_n^{p_n(n)}\\
&Voter \ \textit{m}&: Y_{1,m}&&=y_{1,m}^{p_1(1)} , Y_{2,m}&&=y_{2,m}^{p_2(2)} ,.., Y_{n,m}&&=y_n^{p_n(n)}
\end{alignat*}


\noindent
When computing the encryption of the shares $Y_i$, then each voter will compute the the above to each of the talliers. For clarification we add the tallier to the notation such that we have $Y_{ij}$ where $i$ is the $i$-th voter and $j$ is the $j$-th tallier. \\


\noindent
\textbf{Constructing the Proofs $Proofu$ and $DLEQ$}\\
As briefly described in the previous section, the voter also publishes proofs that he have voted and distributed this vote accurately. The $DLEQ$, proofs that each share have been constructed in the same manner and that this is correct. In order to construct the proofs we need the following variables. 

\begin{alignat*}{3}
hidden \ coeffiens &: C_j = g^{\alpha_j},\ j \in \{0,1,2,3,....,t-1 \}, \ where \ \alpha_0 = s  \\ 
multiplum \ of \ hidden \ coeffiens &: X_i = \prod\limits_{j=0}^{t-1} C_j^{i^j} =g^{p(i)}, 1\leq i\leq n
\end{alignat*}

\noindent
$C_j$ holds all the coeffiens $\alpha_j$ including the secret $\alpha_j^0$, as these are hidden in the exponent of $G$, this is secured by the DL problem. \\


\noindent
The following is the computation of the $X_i$ to tallier 1 ($X_1$), tallier 2 ($X_2$) and tallier 3 ($X_3$).


\begin{alignat*}{3}
X_1 &=\prod\limits_{j=0}^{t-1} C_j^{i^j} &&= C_0^{1^0}  \cdot  C_1^{1^1}  \cdot  C_2^{1^2}\\
X_2 &=\prod\limits_{j=0}^{t-1} C_j^{i^j} &&= C_0^{2^0}  \cdot  C_1^{2^1}  \cdot  C_2^{2^2}\\
X_3 &=\prod\limits_{j=0}^{t-1} C_j^{i^j} &&= C_0^{3^0}  \cdot  C_1^{3^1}  \cdot  C_2^{3^2}
\end{alignat*}


\subsection{Tallying}
\textbf{Elaboration of computation of  $Y_{i}^*$ and $S_i^*$}\\
 As described in section \ref{sec:tallying} the $Y_i^*$ is then the multiplum of encrypted shares for a given tally $i$ and $S_i^*$ is the decrypted multiplum of all tally $i$ shares.

\begin{flalign*}
Multiplum \ of \ encrypted \ shares &: Y_i^*=(\prod\limits_{j=1}^{m} Y_{ij}) \ (mod\ 2 \cdot q+1) =y_i^{\sum\limits_{j=1}^m p_j(i)}\\
Decrypted \ multiplum \ of \ shares &: S_i^*=(Y_{i}^*)^{\frac{1}{x_i}} \ (mod\ 2 \cdot q+1) = G^{ \sum\limits_{j=1}^m p_j(i)}
\end{flalign*}

\noindent
$Y_i^*$ is equal to $y_i^{\sum\limits_{j=1}^m p_j(i)}$ and $S_i^*$ is equal to $ G^{ \sum\limits_{j=1}^m p_j(i)}$. 

\begin{alignat*}{2}
y_i^{\sum\limits_{j=1}^m p_j(i)}=(G^{x_i})^{\sum\limits_{j=1}^m p_j(i)} = G^{x_i \sum\limits_{j=1}^m p_j(i)}= (G^{x_i \sum\limits_{j=1}^m p_j(i)})^{\frac{1}{\mathbf{x_i}}}= G^{ \sum\limits_{j=1}^m p_j(i)}
\end{alignat*}


\noindent
We derive  $S_i^*$ by applying the talliers private key to $Y_i^*$. Note that we are raising to the multiplicative inverse of the private key in  \textit{q}. The $p_j$ is the polynomium $p$ used by the $j$-th voter. More concrete this can be written as the following.

\begin{alignat*}{3}
Y_1^* &= y^{(p_1(1) + p_2(1) + p_3(1),.., p_n(1))}, \ &&S_1^* &&= G^{(p_1(1) + p_2(1) + p_3(1),.., p_n(1))}  \\
Y_2^* &= y^{(p_1(2) + p_2(2) + p_3(2),.., p_n(2))}, \ &&S_2^* &&= G^{(p_1(2) + p_2(2) + p_3(2),.., p_n(2))} \\
Y_n^* &= y^{(p_1(n) + p_2(n) + p_3(n),.., p_n(n))}, \ &&S_n^* &&= G^{(p_1(n) + p_2(n) + p_3(n),.., p_n(n))}
\end{alignat*}



\noindent
Each tallier can publish $S_i^*$ and $Y_i^*$. Note that exponent on the $y$ and $G$ is the evaluation from each voter in some point in a given polynomial $h(1)= p_1(1) + p_2(1) + p_3(1),.., p_n(1),\ h(2)= p_1(2) + p_2(2) + p_3(2),.., p_n(2),...,\ h(n)=p_1(n) + p_2(n) + p_3(n),.., p_n(n) $.


\begin{center}
Tallier 1 publish: \begin{math}S_1^* = G^{ \sum\limits_{j=1}^m p_j(1)}   \end{math} and $Y_i^*= y_i^{\sum\limits_{j=1}^m p_j(1)}$\\
Tallier 2 publish: \begin{math}S_2^* = G^{ \sum\limits_{j=1}^m p_j(2)}   \end{math} and $Y_i^*= y_i^{\sum\limits_{j=1}^m p_j(2)}$\\
Tallier \textit{n} publish: \begin{math}S_n^* = G^{ \sum\limits_{j=1}^m p_j(n)}  \end{math} and $Y_i^*= y_i^{\sum\limits_{j=1}^m p_j(n)}$
\end{center}



%--------------------------------------------------------------------------
\section{Proofs} \label{sec:proofs}
%--------------------------------------------------------------------------
In this section we will elaborate the mathematical justification of the proofs $DLEQ$ and $PROOF_U$. We will present an interactive and a non-interactive proof of the $DLEQ$ between the voter and the verifier.

%----------------------------------------------------------------------
\subsection{DLEQ interactive proof between voters and verifier} \label{proofs:dleq_voter_verifier}
%----------------------------------------------------------------------
DLEQ stands for discrete logarithm equality. It proofs that the exponent are equal $X_i=g^{p(i)}$ and  $Y_i=y_i^{p(i)}$ without revealing \begin{math}{p(i)} \end{math} and if the prover is honest, then it should be the case that we get the same computed values in the end meaning $a_1 = g^w= g^r \cdot X_i^C$ and $a_2= y_i^w = y_i^r \cdot Y_i^C$. We will present the protocol and after that we will give concrete examples. Last we will describe the mathematical justification.\\

\noindent
The verification of the shares in the interactive proof happens by the following  interaction between the prover and the verifier.


\begin{figure}[H]
    \centering        
    
    $
    \begin{array}{l}
    \hline                      \
    \textbf{DLEQ protocol}      \\
    \hline                      \
    Public:  g,X_i,y_i,Y_i \ where \ X_i = g^{x_i} \ and \ Y_i=y_i^{x_i}     \\
    \\
	\begin{array}{L{2cm}ccc}
        & \text{\textsf{Prover}} & & \text{\textsf{Verifier}} \\
        \hline
        Step \ 1 & w\in_R \Z_q & & \\
        & a_1=g^w     & & \\
        & a_2=y_i^w   & \xrightarrow{\hspace{1em}a_1, \ a_2\hspace{1em}} & \\
        Step \ 2 & & & C\in_R \Z_q \\
        & & \xleftarrow{\hspace{2em}C\hspace{2em}} & \\
        Step \ 3 & r=w-p(i)  \cdot  C    & & \\
        Step \ 4 & & \xrightarrow{\hspace{2em}r\hspace{2em}} & \begin{array}{c}
        checks \ if: \\      
        a_1 = g^r \cdot X_i^C \\ 
        a_2=y_i^r \cdot Y_i^C
        \end{array} \\
        \hline
    \end{array}
    \end{array}
    $    
    \caption{DLEQ interactive}
	\label{fig:DLEQ_interactive}
\end{figure}
	


\noindent
Note that the verifier sends a challenge \textit{C}, after the prover has computed \begin{math}a_1\end{math} and  \begin{math}a_2\end{math}. The check only passes if the prover used the same exponents. The proof shows that there exist some element \begin{math} \alpha\end{math} such that \begin{math}g^\alpha = X_i \ \land \ y_i^\alpha=Y_i \end{math}. In the following there is an argument why $DLEQ$ works through Zero knowledge proof.\\ 



\noindent
\textbf{Correctness for $DLEQ$}\\
Correctness means if the prover is honest and the statement is true, then the honest verifier always accept. Correctness is shown by verifying the $a_1=g^w \stackrel{?}{=} g^r \cdot X_i^C$ and $a_2=y_i^w \stackrel{?}{=} y_i^r \cdot Y_i^C$ are well constructed. Correctness for $a_1$ is shown by the following.



\begin{alignat*}{3}
a_1 &= g^r \cdot X_i^C \\
&= g^r \cdot (g^{p(i)})^C \\
&= g^r \cdot g^{p(i) \cdot C}\\
&=g^{r+p(i) \cdot C}      \\
&= g^{w - p(i) \cdot C + p(i) \cdot C} &= g^w
\end{alignat*}


\noindent
Correctness for $a_2$ is shown by the following.


\begin{alignat*}{3}
a_2 &= y_i^r \cdot Y_i^C\\
&= y_i^r \cdot (y^{p(i)})^C \\
&= y_i^r \cdot y^{p(i) \cdot C}\\
&=y_i^{r+p(i) \cdot C}      \\
&= y_i^{w - p(i) \cdot C + p(i) \cdot C} &= y_i^w
\end{alignat*}



\noindent
\textbf{Example on $DLEQ$ and why we need a random challenge}\\
We will show a concrete example why we need a challenge and it needs to be random. If the challenge is already is known by the prover for example  assume say it is 1, then the prover can "prepare" and cheat with a wrong statement. 


\begin{enumerate}
    \item The prover sends \begin{math}a_1=g^6 \ \land\ a_2=y_i^7 \ \land \ X_i=g^2 \ \land \ Y_i=y_i^3 \end{math} to verifier.
    \item The verifier creates a challenge \begin{math}C=1 \end{math} to prover.
    \item The prover computes \begin{math}r=w-p(i)  \cdot  C = 6-2  \cdot  1= 4\end{math} and sends $r$ to verifier.
    \item The verifier knows the following  \begin{math}a_1=g^4  \cdot  X_i \ \land \ a_2=y_i^4  \cdot  Y_i \end{math} and now he verifies:
    \begin{enumerate}        
        \item The verifier checks if:  \begin{math}a_1 = g^4 \cdot X_i^C = g^4 \cdot g^{2 \cdot 1} = g^6\end{math}
        \item The verifier checks if:  \begin{math} a_2=y_i^4  \cdot  Y_i^C = y_i^4  \cdot  y_i^{3 \cdot 1}= y_i^7 \end{math}
    \end{enumerate}
\end{enumerate}


\noindent
One can see that both checks passes in this example despite that the prover is dishonest. This shows that if there is no random challenge there wouldnt be soundness because the prover could cheat.\\

\noindent
\textbf{Example on $DLEQ$ with a random challenge which satisfies soundness}\\
Next example shows the verification with a random challenge.

\begin{enumerate}
    \item The prover sends \begin{math}a_1=g^6 \ \land\ a_2=y_i^7 \ \land \ X_i=g^2 \ \land \ Y_i=y_i^3 \end{math} to verifier.
    \item The verifier creates a challenge \begin{math}C=9\ (mod \ 5) \end{math} to prover.
    \item The prover computes \begin{math}r=w-p(i)  \cdot  C = 6-2  \cdot  4 \ (mod \ 5)= 3\end{math} and sends $r$ to verifier.
    \item The verifier knows the following  \begin{math}a_1=g^3  \cdot  X_i \ \land \ a_2=y_i^3  \cdot  Y_i \end{math} and now he verifies:
    \begin{enumerate}        
        \item The verifier checks if: \begin{math}a_1 = g^3 \cdot X_i^C = g^3 \cdot g^{2 \cdot 4} = g^3  \cdot  g^3 = g^6= g^1= g\end{math}
        \item The verifier checks if: \begin{math} a_2=y_i^3  \cdot  Y_i^C = y_i^3  \cdot  y_i^{3 \cdot 4}= y_i^3  \cdot  y_i^{1 \cdot 2}= y_i^3  \cdot  y_i^2= y^5=y^0= 1 \end{math}
    \end{enumerate}
\end{enumerate}

\noindent
Note that soundness is full filled because the check doesn't pass because $a_1=g^6$ is different from $a_1=g$ and $a_2=y_i^7$ is different from $ a_2=y_i^0$. Recall that soundness is if the statement is false then it should fail with overwhelming probability.\\

\noindent
\textbf{The mathematical justification for soundness}\\
In the following we are showing that a prover will fail with overwhelming probability if he is dishonest which satisfies soundness. Since the verifier doesent know that if the first step \begin{math}X_i=g^{p(i)}  \land Y_i=y_i^{p(i)} \end{math} has been computed correctly we denote these exponents by \begin{math}a_1=g^w\end{math}    and \begin{math}a_2=y_i^{w^{'}}\end{math} and \begin{math}X_i=g^{m_i}\end{math}    and \begin{math}Y_i=y_i^{m_i^{'}}\end{math}. We know \begin{math} a_1= g^w \end{math} is equal to \begin{math}g^r  \cdot  X_i^C=g^r \cdot g^{m_i \cdot C} = g^{r+m_i \cdot C}\end{math} and \begin{math} a_2= y_i^{w^{'}}\end{math} is equal to \begin{math}y_i^r  \cdot  Y_i^C=y_i^r \cdot y_i^{m_i^{'} \cdot C} = y_i^{r+m_i^{'} \cdot C}\end{math}. Based on this we can now write two inequalities. In order for these inequalities to be true we can rewrite.

\begin{alignat*}{5}
 a_1 &= g^w &&= g^r  \cdot  X_i^C &&=g^r \cdot g^{m_i \cdot C} &&= g^{r+m_i \cdot C}\\
 a_2 &= y_i^{w^{'}} &&= y_i^r  \cdot  Y_i^C &&=y_i^r \cdot y_i^{m_i^{'} \cdot C} &&= y_i^{r+m_i^{'} \cdot C}
\end{alignat*}

\noindent
We can now write two inequalities

\begin{alignat*}{5}
 w &= r+m_i  \cdot  C\ (mod\ q) &&\implies r &&= w-m_i \cdot C\ (mod\ q)\\
 w^{'} &= r+m_i^{'}  \cdot  C\ (mod\ q) &&\implies r &&= w^{'}-m_i^{'}  \cdot  C\ (mod\ q)
\end{alignat*}
\noindent
These two inequalities has to be equal, therefor we can rewrite

\begin{alignat*}{5}
w-m_i \cdot C = w^i-m_i^{'}\ (mod\ q) \implies (w-w^i)-(m_i - m_i^{'})  \cdot  C = 0 \ (mod\ q) 
\end{alignat*}


\noindent
The prover has to be honest if this equation must be true. It is overwhelming unlikely that, if the prover has been dishonest, where $m_i \neq m_{i^{'}}$, that he will succeed. Since the $C$ is known afterwards the construction of $w$ and $w^{'}$ the probability will be \begin{math} \frac{1}{q}\end{math} for a convincing the verifier. Since the $q$ is a large number then the probability is for the dishonest prover to succeed.\\


\noindent
\textbf{Zero knowledge}\\
The zero knowledge in this context means that the verifier doesn't learn anything about the $p(i)$. One way to argue zero knowledge is by showing that the values sent in the protocol doesn't depend on the $p(i)$. So if one can construct the values $a_1, \ a_2, \ r$  without knowing  $p(i)$  shows that they do not depend on $p(i)$ and we thereby do not learn anything about $p(i)$. One way of doing this is though experiment where on can change the order of the protocol. In is out of this thesis scope to go further depth on this subject.\\

%----------------------------------------------------------------------
\subsection{DLEQ non-interactive proof between voters and verifier}
%----------------------------------------------------------------------
Here we present how one can turn an interactive proof to a non interactive proof. This is also known as the Fiat Shamir where we are transforming a interactive proof into a non interactive proof (signature scheme). Instead of the verifier computes a challenge, the prover computes the challenge as a random function (hash).  We will present two ways off doing this transformation, a non optimized and a optimized version. Last we will describe an example on how this can be done.\\


\parahead{The prover computes} \begin{math}a_1=g^w \ (mod\ q)  \land a_2=y_i^w \ (mod\ q),  w\in_R \Z_q \end{math}. Then the prover computes the hash \begin{math}C=H(X_i,Y_i,a_1,a_2) \end{math}. Then the prover computes  \begin{math}r=w-p(i)  \cdot  C \ (mod\ q)\end{math}. Last the prover publish \begin{math}a_1, a_2,r,C\end{math}. \\

\noindent
\parahead{The verifier computes} the following computations \begin{math}a_1 = g^r \cdot X_i^C  \ (mod\ q)\end{math} and \begin{math} a_2=y_i^r  \cdot  Y_i^C \ (mod\ q)\end{math} and \begin{math}C=H(X_i,Y_i,a_1,a_2)\end{math}.


\begin{figure}[H]
    \centering        
    
    $
    \begin{array}{l}
    \hline                      \
    \textbf{DLEQ protocol}      \\
    \hline                      \
    Public:  g,X_i,y_i,Y_i   \ where \ X_i = g^{x_i} \land Y_i=y_i^{x_i}
    \\
	\begin{array}{L{1.1cm}lcl}
        & \text{\textsf{Prover}} & & \text{\textsf{Verifier}} \\
        \hline
        Step \ 1    &           \begin{array}{l}
                                    w\in_R \Z_q             \\ 
                                    a_1=g^w \ (mod\ q)      \\ 
                                    a_2=y_i^w \ (mod\ q)    \\
                                    C=H(X_i,Y_i,a_1,a_2)    \\
                                    r=w-p(i)  \cdot  C \ (mod\ q)
                                \end{array}     &               & \\
                    &                   &               & \\
        Step \ 2    &                   &               \xrightarrow{\hspace{0.4em}a_1 , a_2 , r , C\hspace{0.4em}} & \begin{array}{l}
            checks \ if: \\      
            a_1 = g^r \cdot X_i^C \\ 
            a_2=y_i^r \cdot Y_i^C \\
            C=H(X_i,Y_i,a_1,a_2)
        \end{array} \\
        \hline
    \end{array}
    \end{array}
    $    
    \caption{DLEQ non interactive}
	\label{fig:DLEQ_1}
\end{figure}


\noindent
Note in above that there is no interaction between the prover and the verifier. \\

\noindent 
\textbf{DLEQ optimized}\\
In the following we will show how one can improve the amount of computation of the challenge \textit{C}. Instead of computing the challenge \textit{n} times, one can compute it once and reuse the challenge.

\begin{enumerate}
    \item The prover publish  \begin{math}a_{1,i}=g^{w_i} \ (mod\ q)  \land a_{2,i}=y_i^{w_i} \ (mod\ q)\end{math}  for  \begin{math} 1\leq i \leq n, \ w_i\in_R \Z_q \end{math}.
    \item The prover computes the hash \begin{math}C=H(X_i,Y_i,...,X_n,Y_n,a_{1,1},a_{2,1},\\a_{1,2},a_{2,2},...,a_{1,n},a_{2,n})\end{math}.
    \item The prover computes \begin{math}r_i\end{math}:  \begin{math}r_i=w_i-p(i)  \cdot  C \ (mod\ q)\end{math} and publish \begin{math}r_i,C\end{math}.
    \item The verification contains of the following computation:
    \begin{enumerate}        
        \item The verifier checks if:   \begin{math}a_{1,i} = g^{r,i} \cdot X_i^C \ (mod\ q) \end{math}
        \item The verifier checks if:  \begin{math} a_{2,i}=y_i^{r_{i}}  \cdot  Y_i^C \ (mod\ q)\end{math}
         \item The verifier checks if:  $C=H(X_i,Y_i,...,X_n,Y_n,a_{1,1},a_{2,1},$\\
$a_{1,2},a_{2,2},...,a_{1,n},a_{2,n})$
    \end{enumerate}
\end{enumerate}

\noindent 
\textbf{DLEQ computation for 3 voters}\\
Hence the hash contains all the  \begin{math}a_i \end{math} the prover will compute this proof once for all  \begin{math}p(i) \end{math} which improve efficiency. This means that if there are 3 voters, then the above computation has to be done 3 times for every tallier, but same hash can be computed once for every tallier. 



\begin{enumerate}
    \item The prover publish $a_{1,1},a_{2,1},a_{1,2},a_{2,2},a_{1,3},a_{2,3}$.
    \item The prover publish $C,r_1,r_2,r_3$.
    \item The prover selects  $w_1, w_2,w_3\in_R \Z_q$.
    \item The prover computes $a_{1,i}=g^w_i \ (mod\ q) \land a_{2,i}=y_i^{w_i} \ (mod\ q)$.
    \item The prover computes the hash  $C=H(X_i,Y_i,...,X_n,Y_n,a_{1,1},a_{2,1},$\\
$a_{1,2},a_{2,2},...,a_{1,n},a_{2,n})$.
    \item The prover computes $\ r_i:  r_i=w_i-p(i)  \cdot  C \ (mod\ q)$ .
    \item The verification contains of the following computation:
    \begin{enumerate}        
        \item The verifier checks if: $a_{1,i} = g^{r,i} \cdot X_i^C \ (mod\ q) $
        \item The verifier checks if:$a_{2,i} =y_i^{r_{i}}  \cdot  Y_i^C \ (mod\ q)  $ 
         \item The verifier checks if: $C=H(X_i,Y_i,...,X_n,Y_n,a_{1,1},a_{2,1},$\\
$a_{1,2},a_{2,2},...,a_{1,n},a_{2,n})$
    \end{enumerate}
\end{enumerate}



\noindent
\textbf{Zero knowledge proof for the $DLEQ$}\\
The same arguments holds for correctness, soundness and zero knowledge, which is described in section \ref{proofs:dleq_voter_verifier} about the interactive $DLEQ$. 

%----------------------------------------------------------------------
\subsection{Description of $ \mathbf{PROOF_U} $}
%----------------------------------------------------------------------
In this section we show with $PROOF_U$ that the voter either votes  1 or 0. The voter proves that there is consistency between the exponents of how \begin{math}U\end{math} and \begin{math}C_0\end{math} and is constructed from \begin{math}U=G^{s+v}\end{math} and \begin{math}C_0 = g^s\end{math} and the exponents only differs from the vote hence 0 or 1. We will show the interactive proof and through Fiat–Shamir  we transform an interactive proof of knowledge into a non-interactive proof of knowledge. The protocol illustration includes both scenarios where the voter votes either 0 or 1. If the voter votes 0 step 1a, 2, 3a, 4 will be followed. If the voter votes 1 step 1b, 2, 3b, 4 will be followed.\\

\begin{figure}[H]
    \centering        
    
    $
    \begin{array}{l}
    \hline                      \
    \textbf{$PROOF_U$ protocol}      \\
    \hline                      \
    Public:  U=G^{s+v},\ C_0=g^s       \\
    \\
	\begin{array}{L{1.4cm}lcr}
        & \text{\textsf{Prover}} & \text{\textsf{Verifier}} \\
        \hline
        Step \ 1a   &           \begin{array}{l}
                                    if\ vote (v) = 0             \\ 
                                    w\in_R \{1,...,q-1\}, \\ 
                                    r_1\in_R\{1,...,q-1\},\\
                                    d_1\in_R\{1,...,q-1\},      \\ 
                                    a_0 = g^w,\\ 
                                    a_1 = g^{r_1} \cdot C^{d_1}_0,\\ 
                                    b_0 = G^w,  \\
                                    b_1 = G^{r_1}  \cdot  (\frac{U}{G^{1-v}})^{d_1} = G^{r_1}  \cdot  (\frac{U}{G})^{d_1} \\
                                \end{array}     &               & \\
                                \\
                    &                   \xrightarrow{\hspace{1em}a_0, a_1, b_0, b_1\hspace{1em}} \ \textbf{Publish to bulletin}&  & \\                                
                    &                   &               & \\
        Step \ 1b   &           \begin{array}{l}
                                    if\ vote (v) =1             \\ 
                                    w\in_R \{1,...,q-1\},\\ r_0\in_R\{1,...,q-1\},\\
                                    d_0\in_R\{1,...,q-1\},      \\ 
                                    a_0 = g^{r_0} \cdot C^{d_0}_0,\\
                                    a_1 = g^w,\\
                                    b_0 = G^{r_0}  \cdot  (\frac{U}{G^{1-v}})^{d_0}= G^{r_0}  \cdot  U^{d_0} ,\\
                                    b_1 = G^w\\
                                \end{array}     &               & \\
                    &                   &               & \\
                    \\
                    &                   \xrightarrow{\hspace{1em}a_0, a_1, b_0, b_1\hspace{1em}} \ \textbf{Publish to bulletin} & \\
        Step \ 2    &                    & \begin{array}{l}
                                \textbf{Create \ challenge:} \\      
                                C\in_R \{0,...,q-1\} \\ 
                                \xleftarrow{\hspace{2em}C\hspace{2em}}\\
                                \end{array}  \\
        Step \ 3a   &          \begin{array}{l}
                                   if\ vote (v) = 0             \\ 
                                   d_0= C-d_1\ mod\ q,\\
                                   r_0=w-s \cdot d_0 \ mod\ q\\  
                                \end{array}     &               & \\
                                \\
                    &                   \xrightarrow{\hspace{1em}d_0,\ r_0,\ d_1,\ r_1\hspace{1em}} \ \textbf{Publish to bulletin}&  & \\                                
                    &                   &               & \\
        Step \ 3b   &           \begin{array}{l}
                                    if\ vote (v) =1             \\ 
                                    d_1= C-d_0\ mod\ q, \\
                                    r_1=w-s \cdot d_1 \ mod\ q\\ 
                                \end{array}     &               & \\
                                \\
                    &                   \xrightarrow{\hspace{1em}d_0,\ r_0,\ d_1,\ r_1\hspace{1em}} \ \textbf{Publish to bulletin}&  &\\
                    &                   &               & \\
        Step \ 4   &                    & \begin{array}{l}
                                \textbf{Verification:} \\      
                                C = d_1 + d_0,\\
                                a_0=g^{r_0}  \cdot  C^{d_0}_0,\\
                                b_0 = G^{r_0} \cdot U^{d_0},\\
                                a_1=g^{r_1}  \cdot  C^{d_1}_0,\\
                                b_1= G^{r_1}  \cdot (\frac{U}{G})^{d_1} \\ 
        \end{array} \\
        \hline
    \end{array}
    \end{array}
    $    
    \caption{$PROOF_U$}
	\label{fig:PROOF_U}
\end{figure}

\noindent
\textbf{Explanation of the protocol}\\
In step 1 the voter publish \begin{math}a_0,\ b_0,\ a_1,\ b_1\end{math}. Note that the difference between voting 0 or 1 is just by swapping the values between the variables \begin{math}a_0,\ b_0\end{math} and \begin{math}a_1,\ b_1\end{math}. The point is that the verifier will not be able to distinguish the value of the vote and thereby gain knowledge about the vote.



\begin{description}
    \item[Step 1:] Voter either votes $0$ or $1$:
                    \begin{enumerate}
                        \item  Voter votes 0 and creates: \begin{math}v=0,\ w\in_R \{1,...,q-1\},\ r_1\in_R\{1,...,q-1\},\ d_1\in_R\{1,...,q-1\}\end{math} and 
                                publish: \begin{math}a_0 = g^w,\ b_0 = G^w,\ a_1 = g^{r_1} \cdot C^{d_1}_0,\ b_1 = G^{r_1}  \cdot  (\frac{U}{G^{1-v}})^{d_1} = G^{r_1}  \cdot  (\frac{U}{G})^{d_1} \end{math}.
                        \item  Voter votes 1 and creates: \begin{math}v=1,\ w\in_R \{1,...,q-1\},\ r_0\in_R\{1,...,q-1\},\ d_0\in_R\{1,...,q-1\}\end{math} and publish: \begin{math}a_1 = g^w,\ b_1 = G^w,\ a_0 = g^{r_0} \cdot C^{d_0}_0,\ b_0 = G^{r_0}  \cdot  (\frac{U}{G^{1-v}})^{d_0}=  G^{r_0}  \cdot (\frac{U}{1})^{d_0}  =  G^{r_0}  \cdot  U^{d_0} \end{math}
                    \end{enumerate}

    

    
    \item[Step 2:] The verifier creates a challenge \begin{math}C\in_R \{0,...,q-1\}\end{math} to the voter.
    

    
    
    \item[Step 3:] The outcome from step 3 is that the voter publish \begin{math}d_0,\ r_0,\ d_1,\ r_1\end{math}. Note that the voters computation depends on the challenge from the interaction between the verifier. Voter either votes $0$ or $1$:
        \begin{enumerate}
            \item  Voter votes 0 computes: \begin{math}v=0,\ d_0= C-d_1\ mod\ q, \ r_0=w-s \cdot d_0 \ mod\ q\end{math}
            \item  Voter votes 1 computes: \begin{math}v=1,\ d_1= C-d_0\ mod\ q, \ r_1=w-s \cdot d_1 \ mod\ q\end{math}
        \end{enumerate}
    
        
    \item[Step 4:] In step 4 the verifier will be able computes and verify consistency.
    \begin{math}C = d_1 + d_0,\ a_0=g^{r_0}  \cdot  C^{d_1}_0,\ b_0 = G^{r_0} \cdot U^{d_0},\ a_1=g^{r_1}  \cdot  C^{d_1}_0,\ b_1= G^{r_1}  \cdot (\frac{U}{G})^{d_1}\end{math}
\end{description}

\noindent
We can turn this into a non-interactive proof by replacing step 2 with the voter using a hash function and thereby avoiding interaction with the verifier. The prover will then compute a hash of \begin{math}C=H(U,\ C_0,\ a_0,\ b_0,\ a_1,\ b_1) \end{math}.\\




\noindent
\textbf{Mathematical justification for correctness}\\
In the following we derive the mathematical justification from step 4. Here we will replace with earlier expression from above and replace by the actual value of the vote. This means is that the math depends on the value of the vote.\\

\noindent
\textbf{Explanation of \begin{math}a_0=g^{r_0}  \cdot  C^{d_0}_0\end{math}}\\

\noindent
The voter votes 0 and we show that \begin{math}a_0= g^w \stackrel{?}{=} g^{r_0}  \cdot  C^{d_0}_0 \end{math} is well constructed
\begin{align*}
    a_0 &=g^{r_0}  \cdot  C^{d_0}_0     \\ 
        &= g^{w-sd_0} \cdot  g^{sd_0}   \\
        &= g^{w-sd_0+ sd_0}             \\
        &= g^w                          
\end{align*}
The voter votes 1 is trivial because \begin{math}a_0 \end{math}  is constructed from \begin{math}a_0=g^{r_0}  \cdot  C^{d_0}_0 \end{math}\\



\noindent
\textbf{Explanation of \begin{math}b_0 = G^{r_0} \cdot U^{d_0}\end{math}}\\

\noindent
The voter votes 0 and we show that \begin{math}b_0 =  G^w  \stackrel{?}{=} G^{r_0} \cdot U^{d_0} \end{math} is well constructed
\begin{align*}
    b_0 &= G^{r_0} \cdot U^{d_0}                    \\
        &= G^{w-sd_0} \cdot G^{(s+0) \cdot d_{0}}   \\
        &= G^{w-sd_0} \cdot G^{sd_{0}}              \\
        &= G^w                                          
\end{align*}
The voter votes 1 and we show that \begin{math}b_0 = G^{r_0} \cdot (\frac{U}{G^{1-1}})^{d_0} \stackrel{?}{=}  G^{r_0} \cdot U^{d_0} \end{math}
\begin{align*}
    b_0 &= G^{r_0} \cdot (\frac{U}{G^{1-v}})^{d_0}  \\
        &= G^{r_0} \cdot (\frac{U}{G^{0}})^{d_0}    \\
        &= G^{r_0} \cdot (\frac{U}{1})^{d_0}        \\
        &= G^{r_0} \cdot U^{d_0}  
\end{align*}



\noindent
\textbf{Explanation of \begin{math}a_1=g^{r_1}  \cdot  C^{d_1}_0\end{math}}\\

\noindent
The voter votes 1 and we show that \begin{math}a_1=g^w \stackrel{?}{=} g^{r_1}  \cdot  C^{d_1}_0 \end{math} is well constructed
\begin{align*}
    a_1 &= g^{r_1}  \cdot  C^{d_1}_0    \\
        &= g^{w-sd_1} \cdot  g^{sd_1}   \\
        &= g^{w-sd_1+ sd_1}             \\
        &= g^w
\end{align*}
The voter votes 0 is trivial because \begin{math}a_1 \end{math} is constructed from \begin{math}a_1=g^{r_1}  \cdot  C^{d_1}_0 \end{math}.\\


\noindent
\textbf{Explanation of \begin{math}b_1= G^{r_1}  \cdot (\frac{U}{G})^{d_1}\end{math}}\\

\noindent
The voter votes 1 and we show that \begin{math}b_1=   G^W \stackrel{?}{=} G^{r_1}  \cdot (\frac{U}{G})^{d_1} \end{math} is well constructed \begin{align*}
    b_1 &= G^{r_1}  \cdot (\frac{U}{G})^{d_1}                   \\
        &= G^{w-sd_1} \cdot (U \cdot G^{-1})^{d_1}              \\
        &= G^{w-sd_1} \cdot  (G^{s+1})^{d_0} \cdot G^{-d_1}     \\
        &= G^{w-sd_1} \cdot  G^{sd_0+d_0} \cdot G^{-d_1}        \\
        &= G^W
\end{align*}
The voter votes 0 and we show that  \begin{math}b_1= G^{r_1}  \cdot (\frac{U}{G})^{d_1}  \stackrel{?}{=}  G^{r_1}  \cdot (\frac{U}{G^{1-v}})^{d_1} \end{math} is well constructed
\begin{align*}
    b_1 &= G^{r_1}  \cdot (\frac{U}{G^{1-v}})^{d_1}             \\ 
        &= G^{r_1}  \cdot (\frac{U}{G^{1-0}})^{d_1}             \\
        &= G^{r_1}  \cdot (\frac{U}{G})^{d_1}
\end{align*}



\noindent
We will not go to depth in Soundness and Zero knowledge for $PROOF_U$. Here we will refer to another paper. 




%----------------------------------------------------------------------
\subsection{DLEQ proof by the talliers}
%----------------------------------------------------------------------
The tallier will do computations on each of their shares. Each tallier uses the DLEQ to prove that the decryption of their shares is done correctly. It proofs that the exponent are equal \begin{math}G = y_i^{x_i}  \land Y_i=S_i^{x_i} \end{math} without revealing \begin{math}x_i \end{math} and if the prover was honest, then it should be the case that we get same computed values in the end meaning \begin{math}a_1=G^w = G^r \cdot y_i^C\end{math} and \begin{math}a_2=S_i^w = S_i^r \cdot Y_i^C\end{math}.\\

\noindent
First we show the interactive proof and then transform it to a non-interactive proof. The input values are \begin{math}(G,\ y_i,\ S_i, Y_i)\end{math} where \begin{math}G = y_i^{x_i}\end{math} and  \begin{math} Y_i=S_i^{x_i}\end{math}. We have some initial values
 \begin{math}g_1 =G,\ h_i=y_i,\ g_2=S_i,\ h_2=Y_i,\ \alpha=x_i \end{math} and \begin{math}w \in_R \{0,...,q-1\}\end{math}.\\
 
 
 
\noindent 
In step 1 the prover computes \begin{math}a_1=G^w,\ a_2=S_i^w\end{math}. In step 2
the verifier creates a challenge \begin{math}C\end{math}. In step 3 the tallier computes \begin{math}r=w-C \cdot x_i\end{math}. In step 4 the verifier computes \begin{math}a_1=G^r \cdot y_i^C,\ a_2=S_i^r \cdot Y_i^C\end{math}.
 
 
 
\begin{figure}[H]
    \centering        
    
    $
    \begin{array}{l}
    \hline                      \
    \textbf{DLEQ protocol by the talliers}      \\
    \hline                      \
    Input:  G,\ y_i,\ S_i, \ Y_i \ where \ G = y_i^{x_i} \land Y_i=S_i^{x_i}     \\
    Output: 0 \ or \ 1
    \\
	\begin{array}{L{2cm}ccc}
        & \text{\textsf{Prover}} & & \text{\textsf{Verifier}} \\
        \hline
        Step \ 1 & w\in_R \Z_q & & \\
        & a_1=G^w     & & \\
        & a_2=S_i^w   & \xrightarrow{\hspace{1em}a_1 , a_2\hspace{1em}} & \\
        Step \ 2 & & & C\in_R \Z_q \\
        & & \xleftarrow{\hspace{2em}C\hspace{2em}} & \\
        Step \ 3 & r=w-x_i  \cdot  C    & & \\
        Step \ 4 & & \xrightarrow{\hspace{2em}r\hspace{2em}} & \begin{array}{c}
        checks \ if: \\      
        a_1 = G^r \cdot y_i^C \\ 
        a_2=S_i^r \cdot Y_i^C
        \end{array} \\
        \hline
    \end{array}
    \end{array}
    $    
    \caption{DLEQ}
	\label{fig:DLEQ_by_talliers}
\end{figure} 

\noindent
Note the interaction in step 2 where the verifier create a challenge to the prover. Through Fiat–Shamir we transform an interactive proof of knowledge into a non-interactive proof of knowledge by replacing step 2 with a hashing algorithm  \begin{math}C=H(G,\ y_i,\ S_i,\ Y_i,\ a_1,\ a_2)\end{math}.\\
 
 \noindent
\textbf{Mathematical justification}\\
To justify correctness of the computations in step 4, we can do the following verification on \begin{math}a_1=G^w \stackrel{?}{=} G^r \cdot y_i^C\end{math} and \begin{math}a_2=S_i^w \stackrel{?}{=} S_i^r \cdot Y_i^C\end{math}.


\begin{alignat*}{5}
a_1 &=G^r \cdot y_i^C &=G^r \cdot y_{x_i}^C &=G^{r+x_iC} =G^{w-Cx_i+x_iC} =G^w\\
a_2 &= S_i^r \cdot Y_i^C &=S^r \cdot Y_{x_i^C} &=S^{w-Cx_i} \cdot S_i^{x_i \cdot C} =S^{w-Cx_i+x_i \cdot C}&=S_i^w
\end{alignat*}




\noindent
To show soundness and zero knowledge the same process from section \ref{proofs:dleq_voter_verifier} can be followed.