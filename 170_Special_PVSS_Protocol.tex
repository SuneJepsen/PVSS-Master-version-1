In this section we look at the electronic voting protocol described in \cite{Schoenmakers1999}. The protocol is based on the PVSS protocol described in the same article. We will only describe the electronic voting protocol but as doing so, the relevant elements from the PVSS protocol will be taking into the description. For the rest of this chapter we will be referring to the electronic voting protocol, as simply the protocol, unless specified otherwise. \\

\noindent
Giving the complexity of the protocol we divided this description into three parts. In the first part we will describe the protocol as simple as possible, leaving out mathematical justification and proofs.  We provide a calculated example for low values for the basic parts of the protocol in \ref{sec:simple_review_of_calculations_in_the_protocol}.  In second part we will be looking at the mathematical justification, describing this in the same order as in the first part. Finally we will look at the proofs in the last part. 


%--------------------------------------------------------------------------
\section{The protocol}   \label{sec:the_protocol}
%--------------------------------------------------------------------------


\noindent
The overall concept of the protocol is to allow a group of voters to cast there votes in the form "no" or "yes" , and publish the result to a public bulletin board. When a deadline is reach or when all votes have been casted a group of talliers takes the votes and calculates the end result. 
Using MPC and PVSS protocols this is done in such a way that none other then the voter knows the value of his vote, but everyone can validates the correctness and consistence of the vote. Below we present a simple overview showing the progress of the protocol. \\

\noindent
\textbf{Short overview of the protocol}
The protocol is divided into three main parts, each part representing a different phase in the election, roughly put one can say pre-election, the election and post-election. 

\noindent
\begin{enumerate}
    \item \textbf{Initialization}
    This represents the pre-election phase where the preparation for the actually election happens. Here the requirements for the election is demented and the different authorities is registered. 
    
        \begin{enumerate}
            \item The system publishes the system parameters and the security requirements. In our implementation an admin user will log into the system and start the election. The admin will choose the security parameter and the amount of required talliers. Last he will initiate the computation of the system parameters.
            
            \item Each tallier generates a private and a public key.
            
            \item Each tallier registries their public keys on the bulletin board.
            
            \item Each voter signs it credentials on the bulletin board.
        \end{enumerate}
        
    \item \textbf{Ballot casting}
    This represent the actually election, where the registered voters castes there votes and publish the result to the bulletin board. 
    
        \begin{enumerate}
            \item Each voter votes $1$ or $0$
        
            \item Each voter generates a random secret.
        
            \item Each voter creates shares of the secret to each tallier and encrypts it with the corresponding public key of the tallier. Each voter supply this secret share with evidence of its consistency with a $DLEQ$ proof.
        
            \item Each voter supply evidence for a valid vote with $PROOF_U$.
        \end{enumerate}
        
    \item \textbf{Tallying} 
    This represents the post-election phase where the tallying authorities, which where registered in Initialization, counts the votes together and publish the result to the bulletin board.
    
        \begin{enumerate}
            \item At least $t$ tallier accumulates and decrypts their shares.
            
            \item One authority completes the final computation of the total votes.
        \end{enumerate}
\end{enumerate}


\noindent
In the following we will describe the central parts of the protocol, leaving out the complexity of mathematical justification and proofs. The idea is to get an understanding of how the protocol works without know exactly why it works. \\

\noindent
For efficiency we will limit the computation of the votes to a finite number of talliers. There are \textit{m} voters and \textit{n} talliers.
%--------------------------------------------------------------------------
\subsection{Initialization}   \label{sec:the_protocol_initialization}
%--------------------------------------------------------------------------

\noindent
\textbf{The bulletin board publishes all system parameters which is the public elements a prime $q$,  the generators $g$ and $G$ and a security parameter $t$.}


\begin{alignat*}{2}
q \ &\in_R \{2^{l-1},...,2^{l}\}, \ where\  l &&> 1024 \\
f \ &\in_R \{2,...,2q-1\} \rightarrow g &&= f^2 \ mod\ 2q+1  \\
F \ &\in_R \{2,...,2q-1\}\rightarrow G &&= F^2 \ mod\ 2q+1 \\
t &\in \Z_q^* &&= \{1,2,3,...,q-1\} 
\end{alignat*}

\noindent
The prime $q$ is uniformly randomly chosen from $\Z$, but in practise we use the subset $2^{l-1}$ to $2^l$. $l$ is chosen  larger then 1024 because of the security requirements described in section \ref{sec:solving_the_discrete_logarithm_problem}. The generators $g$ and $G$ are computed as squares from the sets $f$ and $F$, the reason for this is elaborated in section \ref{sec:protocol_details_initialization}.  $2q+1$ must also be a prime and the reason why we use $2q +1$ is because we are working with Shamirs secret sharing in the exponents which also is described in section \ref{sec:protocol_details_initialization}. $t$ is chosen based on the system requirements for our fault tolerance against corrupted parties.\\

\noindent
\textbf{The tallier generates a private key $x_i$ and a public key $y_i$.}
\begin{flalign*}
Private \ key &: x_{i} \in_R \Z_q^* = \{1,2,3,...,q-1\}\\
Public \ key &: y_i=G^{x_i} ,\ i \in \{1,2,3,...., n \}
\end{flalign*}

\noindent
Every tally generates a uniformly randomly chosen private key from $\Z_q^*$ where $q$ is a prime. The star notation refers to a set with none greatest common divisor larger then $1$ respectively with $q$, which is described in section \ref{sec:group_theory}. The public key is computed on an exponentation on $G$, which essentially gives us the security of the discrete logarithm problem described in section ~\ref{sec:discrete_logarithm_problem}.

%--------------------------------------------------------------------------
\subsection{Ballot casting}
\label{sec:ballot_casting}
%--------------------------------------------------------------------------
The  Ballot casting consists of \textit{distribution of the shares} and \textit{verification of the shares}.\\

\noindent
First the voter either votes "no" or "yes" corresponding to 0 or 1. The voter select a uniformly random secret $s \in \Z_q$. The PVSS protocol is then used to distribute shares which contain a combination of the secret $s$ and the vote. Every voter will construct a random polynomial at degree $t-1$ and then evaluate the shares  to each of the talliers.\\


\noindent
\textbf{The voter casts his vote, either 0 or 1. The voter creates a random secret $s$ and a random polynomial of degree at most $t-1$ and computes the shares.}

\begin{flalign*}
Vote &: v\in\{0,1\} & \\
Random \ secret  &: s\in_R \Z_q &\\
Random \ polynomium &:  p(x)=s+\alpha_1x^1+\alpha_2x^2+,...,+\alpha_{t-1}x^{t-1}, \ \alpha_j\in_R \Z_q &\\
Secret \ Shares &:  p(0)=s,\ p(1),\ p(2),...,\ p(n)
\end{flalign*}

\noindent
The degree of the polynomium is based on the security parameter $t$ described in section ~\ref{sec:the_protocol_initialization}. Each voter chooses uniformly random the coefficients $\alpha$ in $Z_q$ and a random secret $s$ and computes the shares using Shamirs secret sharing which is described in section \ref{sec:example_computation_using_shamir_secret_sharing}.\\

\noindent
\textbf{The voter distributes the encrypted share and creates the proofs $PROOF_U$ and $DLEQ$.}

\begin{alignat*}{2}
Encryption \ of \ the \ share : Y_i&=y_i^{p(i)} ,1\leq i\leq n \\ 
Hidden \ vote : U&=G^{s+v}
\end{alignat*}

\noindent
Each voter creates encrypted shares to tally $1$, tally $2$,..., tally $n$. The $p(i)$ refers to the share in a point corresponding to a given tally. The shares are encrypted using the tallys public key $y_i$. $U$ is a DL problem that hides the vote as the exponentiation. As the vote $v$ only can hold the values $0$ or $1$ this wouldn't make a hard problem. By reusing the secret $s$ and adding this to $v$, then given a large $s$, $U$ should be a hard problem. The above is then published to the bulletin board. \\

\noindent
Besides the above, the proofs $PROOF_U$ and $DLEQ$ are computed and published. The $PROOF_U$ proofs that the vote is either $0$ or $1$ without revealing the actual value of the vote. The $DLEQ$ proofs that the shares are constructed correctly and consistent. Both proofs are elaborated in details later in section \ref{sec:proofs}

%--------------------------------------------------------------------------
\subsection{Tallying}
\label{sec:tallying}
%--------------------------------------------------------------------------
Tallying is the process of counting the votes. Here the tallier uses their private keys to collectively compute the final tally, based on the valid ballots.\\



\noindent
\textbf{The tally decrypts their shares and publishes a $DLEQ$ proof}

\begin{flalign*}
Multiplum \ of \ encrypted \ shares &: Y_i^*=(\prod\limits_{j=1}^{m} Y_{ij}) \ (mod\ 2 \cdot q+1)
\end{flalign*}

\noindent
The homomorphic secret sharing property ensures that each tally will  be able to multiply the shares and then decrypt. Let $Y_{ij}$ be the value $Y_i$ computed by the $j$-th voter, which is the encrypted share $Y_i = y_i^{p(i)}$,  as described in the section \ref{sec:ballot_casting}. This means that the $i$ is referring to tally 1, tally  2 and tally 3 etc. and $j$ is referring to voter 1, voter 2 and voter 3 etc. $Y_i^*$ is then the multiplum of encrypted shares for a given tally $i$. Tally $i$ is now able to decrypt the multiplum $Y_i^*$ using his private key $x_i$. 

\begin{flalign*}
Decrypted \ multiplum \ of \ shares &: S_i^*=(Y_{i}^*)^{\frac{1}{x_i}} \ (mod\ 2 \cdot q+1)
\end{flalign*}

\noindent
$S_i^*$ is the decrypted multiplum of all tally $i$ shares. As this is the multiplum of shares then no information of the individual share is revealed and tally $i$ can safely publish the decrypted result to the bulletin board.

\noindent
Note that besides decrypting the shares the talliers will publish a $DLEQ$ proof which shows that the decrypting was done correct. See figure \ref{fig:DLEQ_by_talliers} of the $DLEQ$ proof. Also note that we need to computing the inverse of the key $x_i$. To compute the inverse we can use Extended Euclidean algorithm described in section \ref{sec:modular_arithmetic}.\\


\noindent
\textbf{A master authority applies Lagrange interpolation}\\
After the tallier has published their decrypted shares $S_i^*$ a master authority will be able to compute the sum of the secrets from the voters.


\begin{alignat*}{2}
(S_1^*)^{\lambda_1  \cdot  \ (mod \ q)}  \cdot  (S_2^*)^{\lambda_2 \ (mod \ q)}  \cdot  (S_n^*)^{\lambda_n \ (mod \ q)} \ (mod \ 2 \cdot q+1) = G^{ \sum\limits_{j=1}^m s_j}
\end{alignat*}

\noindent
With all the $S_i^*$ we can compute the sum of the secrets. We apply the lambdas to exponents on $S_i^*$, which is computed from the  Lagrange interpolation formular, \begin{math} \lambda_j \end{math} from section \ref{sec:shamir_secret_sharing_lagrange_interpolation}. We can then multiply the $S_i^*$ which can be  reduces to the sum of the exponents, which are equal to the sum of the secrets.\\


\noindent
\textbf{A master authority computes the votes}\\
The last step is to isolate the votes and then compute the final result. By multiplying \begin{math}U_j \end{math} from the voters we obtain the following.

\begin{alignat*}{2}
(\prod\limits_{j=1}^{m} U_{j}) \ (mod \ 2 \cdot q+1)=  G^{ \sum\limits_{j=1}^m s_j +v_j}
\end{alignat*}

\noindent
From the previous step we computed $G^{ \sum\limits_{j=1}^m s_j}$. To  isolate the sum of votes \textit{v} in the exponent we can multiply  $(\prod\limits_{j=1}^{m} U_{j})$ by the inverse of $(G^{ \sum\limits_{j=1}^m s_j})^{-1}$ in the following.

\begin{alignat*}{2}
 G^{ \sum\limits_{j=1}^m s_j +v_j} \cdot (G^{ \sum\limits_{j=1}^m s_j})^{-1} = G^{ \sum\limits_{j=1}^m v_j}
\end{alignat*}


\noindent
To solve the computing of the votes one can compute \begin{math}G^0, G^1, G^3,..., G^{v_j} \end{math} by exhaustive search. The final vote count will be the exponent raised on $G$. A more efficient algorithm is to use Baby-step giant-step algorithm described in section \ref{sec:solving_the_discrete_logarithm_problem}. 

%--------------------------------------------------------------------------
\section{Protocol details} \label{sec:protocol_details}
%--------------------------------------------------------------------------
In this part we will elaborate on the mathematical justification based on our explanation of the protocol.  


\subsection{Initialization} \label{sec:protocol_details_initialization}
\textbf{Elaboration of computation of  $2q+1$}\\
In our implementation we will pick a prime, \begin{math}q\end{math}, so we avoid doing the gcd computation. The protocol states that we have to compute in a group of order $q$. This means that when we are doing operations in the exponent this property should be satisfied \begin{math}g^q=1\end{math} where \begin{math}q\end{math} is prime. If we are doing \begin{math}mod \ q \end{math} in the exponent we have \begin{math}g^q=g^0\end{math}. The reason for doing operation in the exponent \begin{math}mod \ q\end{math} is because we are using Sharmir secret sharing which require a finite field.\\

\noindent
One can see that given a generator $g=2 $ and a prime $q=5$, then \begin{math}2^5 \ mod \ 5 = 32 \ mod \ 5 = 2\end{math}. For this to be true, we take the square of numbers modulo a prime in this form \begin{math}2q+1\end{math}. This is also called a strong prime. By using this mathematical structure this property holds. We can choose \begin{math}b=a^2\end{math}. Then we see the property holds \begin{math}b^{q} = 1 \ mod \ 2q+1\end{math}. Using the same values as before, it is clear that \begin{math}(2^2)^5 \ mod \ 11 = 1024 \ mod \ 11 = 1\end{math}. Fermat little theorem states that \begin{math}b^{q-1} \ mod \ q = 1\end{math} where \begin{math}q\end{math} is prime. So we know if we pick our \begin{math}q\end{math} and \begin{math}b\end{math} (as a square)  in this form \begin{math}(a^{2})^{q+1-1} \ mod \ 2q+1 =1 =  a^{2q} \ mod \ 2q+1 =1\end{math} the property holds. This means if we are working in the exponents we $(mod \ q)$ and if we are working in the bases we $(mod \ 2q+1)$.\\

\noindent
\textbf{Elaboration of the generators}\\
The generators is randomly chosen in the set between $2$ and $2q-1$.  We remove $1$ because if $1$ get squared it will always gives $1$ and can therefor not be used as a generator. We remove $2q$ because $(2q)^2 = 1 \ mod \ 2q+1$. That means if you square $2q$ it will also give $1$ and can therefor not be used as a generator.

\subsection{Ballot casting}

\textbf{Elaboration of computation of  $Y_i$}\\
The $Y_i$ is the shares encrypted using the talliers public key $y_i$ as described in section \ref{sec:ballot_casting}.
 
\begin{alignat*}{5}
&Voter \ 1 &&: Y_{1,1}&&=y_{1,1}^{p_1(1)},Y_{2,1}&&=y_{2,1}^{p_2(2)} ,.., Y_{n,1}&&=y_n^{p_n(n)}\\
&Voter \ 2 &&: Y_{1,2}&&=y_{1,2}^{p_1(1)},Y_{2,2}&&=y_{2,2}^{p_2(2)} ,.., Y_{n,2}&&=y_n^{p_n(n)}\\
&Voter \ \textit{m}&&: Y_{1,m}&&=y_{1,m}^{p_1(1)} , Y_{2,m}&&=y_{2,m}^{p_2(2)} ,.., Y_{n,m}&&=y_n^{p_n(n)}
\end{alignat*}


\noindent
When computing the encryption of the shares $Y_i$, then each voter will compute the above to each of the talliers. For clarification we add the tally to the notation such that we have $Y_{ij}$ where $i$ is the $i$-th tally and $j$ is the $j$-th voter referring to $ Y_{1,1}, \  Y_{1,2}$ etc. \\


\noindent
\textbf{Constructing the variable $C_j$ and $X_i$ to proofs  $DLEQ$ and $Proofu$}\\
As briefly described in section \ref{sec:ballot_casting}, the voter publishes proofs that he have voted and distributed this vote accurately. The proof $Proofu$ uses the variable $C_0$ and the $DLEQ$ uses the variable $X_i$. In order to construct the proofs each voter creates the following variables. 

\begin{flalign*}
&hidden \ coeffiens : C_j = g^{\alpha_j},\ j \in \{0,1,2,3,....,t-1 \}, \ where \ \alpha_0 = s  \\ 
&multiplum \ of \ hidden \ coeffiens: X_i = \prod\limits_{j=0}^{t-1} C_j^{i^j} =g^{p(i)}, \ 1\leq i\leq n \\ 
\end{flalign*}

\noindent
$C_j$ holds all the coeffiens $\alpha_j$ including the secret $\alpha_0$, as these are hidden in the exponent of $g$, this is secured by the DL problem.\\

\noindent
The $p(i)$ raised in the exponent of $g$ is the polynomial $p(i)=\alpha_0+\alpha_1i^1+\alpha_2i^2+,...,+\alpha_{t-1}i^{t-1}$ created by each voter in the Ballot casting phase described in section ~\ref{sec:ballot_casting}.  The way we can reduce the following statement  $X_i = \prod\limits_{j=0}^{t-1} C_j^{i^j}$ to $g^{p(i)}$ is as follows. 

\begin{flalign*}
 X_i = \prod\limits_{j=0}^{t-1} C_j^{i^j} = \prod\limits_{j=0}^{t-1} (g^{\alpha_j})^{i^j} =g^{ \sum\limits_{j=0}^{t-1} \alpha_j \cdot i^{j}} = g^{ \alpha_0 \cdot i^{0} + \alpha_1 \cdot i^{1}+ \alpha_2 \cdot i^{2},..., \alpha_{t-1} \cdot i^{t-1} }  = g^{p(i)}
\end{flalign*}


\noindent
To clarify, if the voter creates $3$ shares, that means the voter has to compute $X_1$, $X_2$ and $X_3$  which means one $X_i$ foreach share. This makes sense because the voter has to prove his honesty foreach of the shares.


\begin{alignat*}{3}
X_1 &=\prod\limits_{j=0}^{t-1} C_j^{i^j} &&= C_0^{1^0}  \cdot  C_1^{1^1}  \cdot  C_2^{1^2} &&=  g^{ \alpha_0 \cdot 1^{0} + \alpha_1 \cdot 1^{1}+ \alpha_2 \cdot 1^{2}}  = g^{p(1)}\\
X_2 &=\prod\limits_{j=0}^{t-1} C_j^{i^j} &&= C_0^{2^0}  \cdot  C_1^{2^1}  \cdot  C_2^{2^2}  &&=  g^{ \alpha_0 \cdot 2^{0} + \alpha_1 \cdot 2^{1}+ \alpha_2 \cdot 2^{2}}  = g^{p(2)}\\
X_3 &=\prod\limits_{j=0}^{t-1} C_j^{i^j} &&= C_0^{3^0}  \cdot  C_1^{3^1}  \cdot  C_2^{3^2}  &&=  g^{ \alpha_0 \cdot 3^{0} + \alpha_1 \cdot 3^{1}+ \alpha_2 \cdot 3^{2}}  = g^{p(3)}
\end{alignat*}


\subsection{Tallying}
\textbf{Elaboration of computation of  $Y_{i}^*$ and $S_i^*$}\\
 As described in section \ref{sec:tallying} the $Y_i^*$ is then the multiplum of encrypted shares for a given tally $i$ and $S_i^*$ is the decrypted multiplum of all tally $i$ shares.

\begin{flalign*}
Multiplum \ of \ encrypted \ shares &: Y_i^*=(\prod\limits_{j=1}^{m} Y_{ij}) \ (mod\ 2 \cdot q+1) =y_i^{\sum\limits_{j=1}^m p_j(i)}\\
Decrypted \ multiplum \ of \ shares &: S_i^*=(Y_{i}^*)^{\frac{1}{x_i}} \ (mod\ 2 \cdot q+1) = G^{ \sum\limits_{j=1}^m p_j(i)}
\end{flalign*}

\noindent
$Y_i^*$ is equal to $y_i^{\sum\limits_{j=1}^m p_j(i)}$ and $S_i^*$ is equal to $ G^{ \sum\limits_{j=1}^m p_j(i)}$. 

\begin{alignat*}{2}
y_i^{\sum\limits_{j=1}^m p_j(i)}=(G^{x_i})^{\sum\limits_{j=1}^m p_j(i)} = G^{x_i \sum\limits_{j=1}^m p_j(i)}= (G^{x_i \sum\limits_{j=1}^m p_j(i)})^{\frac{1}{\mathbf{x_i}}}= G^{ \sum\limits_{j=1}^m p_j(i)}
\end{alignat*}


\noindent
We derive  $S_i^*$ by applying the talliers private key to $Y_i^*$. Note that we are raising to the multiplicative inverse of the private key in  \textit{q}. The $p_j$ is the evaluations by the $j$-th voter. More concrete this can be written as the following.

\begin{alignat*}{3}
Y_1^* &= y_1^{(p_1(1) + p_2(1) + p_3(1),.., p_n(1))}, \ &&S_1^* &&= G^{(p_1(1) + p_2(1) + p_3(1),.., p_n(1))}  \\
Y_2^* &= y_2^{(p_1(2) + p_2(2) + p_3(2),.., p_n(2))}, \ &&S_2^* &&= G^{(p_1(2) + p_2(2) + p_3(2),.., p_n(2))} \\
Y_n^* &= y_n^{(p_1(n) + p_2(n) + p_3(n),.., p_n(n))}, \ &&S_n^* &&= G^{(p_1(n) + p_2(n) + p_3(n),.., p_n(n))}
\end{alignat*}



\noindent
Each tallier can publish $S_i^*$ and $Y_i^*$. Note that the exponent on the $y_i$ and $G$ is the evaluation from each voter in some point in a given polynomial $h(1)= p_1(1) + p_2(1) + p_3(1),.., p_n(1),\ h(2)= p_1(2) + p_2(2) + p_3(2),.., p_n(2),...,\ h(n)=p_1(n) + p_2(n) + p_3(n),.., p_n(n) $.


\begin{center}
Tally 1 publish: \begin{math}S_1^* = G^{ \sum\limits_{j=1}^m p_j(1)}   \end{math} and $Y_i^*= y_i^{\sum\limits_{j=1}^m p_j(1)}$\\
Tally 2 publish: \begin{math}S_2^* = G^{ \sum\limits_{j=1}^m p_j(2)}   \end{math} and $Y_i^*= y_i^{\sum\limits_{j=1}^m p_j(2)}$\\
Tally \textit{n} publish: \begin{math}S_n^* = G^{ \sum\limits_{j=1}^m p_j(n)}  \end{math} and $Y_i^*= y_i^{\sum\limits_{j=1}^m p_j(n)}$\\
\end{center}

\noindent
\textbf{Elaboration of the step where the master authority applies Lagrange interpolation}


\begin{alignat*}{2}
(S_1^*)^{\lambda_1  \cdot  \ (mod \ q)}  \cdot  (S_2^*)^{\lambda_2 \ (mod \ q)}  \cdot  (S_n^*)^{\lambda_n \ (mod \ q)} \ (mod \ 2 \cdot q+1) = G^{ \sum\limits_{j=1}^m s_j}
\end{alignat*}


\noindent
We can substitute the $S^*$ with $G$. The final result in the exponents is a evaluation in some polynomium in $0$ which corresponds to the sum of secrets $s$ computed by the voters.

\begin{alignat*}{2}
&=G^{ \sum\limits_{j=1}^m \lambda_j p_j(1)} \cdot G^{ \sum\limits_{j=1}^m \lambda_j p_j(2)} \cdot...\cdot G^{ \sum\limits_{j=1}^m \lambda_j p_j(n)}\\
&=G^{ \sum\limits_{j=1}^m \lambda_j p_j(1) +  \sum\limits_{j=1}^m \lambda_j p_j(2) +...+  \sum\limits_{j=1}^m \lambda_j p_j(n)}\\
&=G^{ \sum\limits_{j=1}^m (\lambda_j p_j(1)+\lambda_j p_j(2)+,...,+\lambda_{j}p_j(n))} = G^{ \sum\limits_{j=1}^m p_j(0)}= G^{ \sum\limits_{j=1}^m s_j}
\end{alignat*}


\noindent
The \begin{math}\sum\limits_{j=1}^m p_j(0) \end{math} correspond to the sum of the secret values of \textit{s} for the voters. More formal it corresponds to the evaluation of some polynomial $h(0)= s_1 + s_2,..., s_n$.\\

\noindent
\textbf{Elaboration of the step where the master authority computes the votes}

\begin{alignat*}{2}
Sum \ of \ the \ secrets \ and \ the \  votes: (\prod\limits_{j=1}^{m} U_{j}) \ (mod \ 2 \cdot q+1)=  G^{ \sum\limits_{j=1}^m s_j +v_j}
\end{alignat*}

\noindent
From the previous we saw that by multiplying \begin{math}U_j \end{math} we obtained the sum of the secrets and the votes in the exponent. To recap more concrete we have the following. \\

\noindent
The voters computes $U$


\begin{alignat*}{2}
Voter \ 1 &: U_1 &&=G^{s_1+v_1}\\
Voter \ 2 &:U_2 &&=G^{s_2+v_2}\\
Voter \ n &:U_m &&=G^{s_m+v_m}
\end{alignat*}

\noindent
The  master  authority  mulitplies  the $U$

\begin{alignat*}{2}
(\prod\limits_{j=1}^{m} U_{j}) = U_1 \cdot U_2 \cdot,..., \cdot U_m = G^{s_1 + s_2,...,s_m + v_1 + v_2,..., v_m}
\end{alignat*}

\noindent
To isolate the votes in the exponent we multiply the  $(\prod\limits_{j=1}^{m} U_{j})$ by the inverse of $(G^{ \sum\limits_{j=1}^m s_j})^{-1}$. This leads to the following  mathematical justification.

\begin{alignat*}{2}
\frac{G^{ \sum\limits_{j=1}^m s_j +v_j}}{{ G^{ \sum\limits_{j=1}^m s_j} }} = G^{ \sum\limits_{j=1}^m s_j +v_j -\sum\limits_{j=1}^m s_j} = G^{ \sum\limits_{j=1}^m v_j}
\end{alignat*}


%--------------------------------------------------------------------------
\section{Proofs} \label{sec:proofs}
%--------------------------------------------------------------------------
In this section we will elaborate the mathematical justification of the proofs $DLEQ$ and $PROOF_U$. We will present an interactive and a non-interactive proof of the $DLEQ$ between the voter and the verifier. The non-interactive $DLEQ$ proof is elaborated in appendix \ref{sec:dleq_non-interactive-proof-between_voters_and_verifier}. As mentioned there is also a $DLEQ$ proof provided by the tallier which is elaborated in appendix \ref{sec:dleq_proof_by_the_talliers}.

%----------------------------------------------------------------------
\subsection{DLEQ interactive proof between voters and verifier} \label{sec:dleq_voter_verifier}
%----------------------------------------------------------------------
DLEQ stands for discrete logarithm equality and it proofs that the exponent are equal $X_i=g^{p(i)}$ and  $Y_i=y_i^{p(i)}$ without revealing \begin{math}{p(i)} \end{math} and if the prover is honest, then it should be the case that we get the same computed values in the end meaning $a_1 = g^w= g^r \cdot X_i^C$ and $a_2= y_i^w = y_i^r \cdot Y_i^C$. The prover must compute same amount of $X_i$ as he creates shares. In practice this means that the prover supply a $DLEQ$ proof foreach of the shares. We will present the protocol and after that we will give concrete examples. Last we will describe the mathematical justification. An example of the proof is calculated in appendex \ref{sec:simple_review_of_calculation_of_dleq_between_voter_and_verifier}. \\

\noindent
The verification of the shares in the interactive proof happens by the following  interaction between the prover and the verifier.


\begin{figure}[H]
    \centering        
    
    $
    \begin{array}{l}
    \hline                      \
    \textbf{DLEQ protocol}      \\
    \hline                      \
    Input:  g,X_i,y_i,Y_i \ where \ X_i = g^{\alpha_i} \ and \ Y_i=y_i^{\alpha_i}     \\
    \\
	\begin{array}{L{2cm}ccc}
        & \text{\textsf{Prover}} & & \text{\textsf{Verifier}} \\
        \hline
        Step \ 1 & w\in_R \Z_q & & \\
        & a_1=g^w     & & \\
        & a_2=y_i^w   & \xrightarrow{\hspace{1em}a_1, \ a_2\hspace{1em}} & \\
        Step \ 2 & & & C\in_R \Z_q \\
        & & \xleftarrow{\hspace{2em}C\hspace{2em}} & \\
        Step \ 3 & r=w-p(i)  \cdot  C    & & \\
        Step \ 4 & & \xrightarrow{\hspace{2em}r\hspace{2em}} & \begin{array}{c}
        checks \ if: \\      
        a_1 = g^r \cdot X_i^C \\ 
        a_2=y_i^r \cdot Y_i^C
        \end{array} \\
        \hline
    \end{array}
    \end{array}
    $    
    \caption{$DLEQ$ interactive}
	\label{fig:DLEQ_interactive}
\end{figure}
	


\noindent
Note that the verifier sends a challenge \textit{C}, after the prover has computed \begin{math}a_1\end{math} and  \begin{math}a_2\end{math}. The check only passes if the prover used the same exponents. The proof shows that there exist some element \begin{math} \alpha\end{math} such that $g^\alpha = X_i$ and   $y_i^\alpha=Y_i$. In the following there is an argument why $DLEQ$ works through Zero knowledge proof.\\ 



\noindent
\textbf{Correctness for $DLEQ$}\\
Correctness means if the prover is honest and the statement is true, then the honest verifier always accept. Correctness is shown by verifying the $a_1=g^w \stackrel{?}{=} g^r \cdot X_i^C$ and $a_2=y_i^w \stackrel{?}{=} y_i^r \cdot Y_i^C$ are well constructed. Correctness for $a_1$ is shown by the following.



\begin{alignat*}{3}
a_1 &= g^r \cdot X_i^C \\
&= g^r \cdot (g^{p(i)})^C \\
&= g^r \cdot g^{p(i) \cdot C}\\
&=g^{r+p(i) \cdot C}      \\
&= g^{w - p(i) \cdot C + p(i) \cdot C} &= g^w
\end{alignat*}


\noindent
Correctness for $a_2$ is shown by the following.


\begin{alignat*}{3}
a_2 &= y_i^r \cdot Y_i^C\\
&= y_i^r \cdot (y^{p(i)})^C \\
&= y_i^r \cdot y^{p(i) \cdot C}\\
&=y_i^{r+p(i) \cdot C}      \\
&= y_i^{w - p(i) \cdot C + p(i) \cdot C} &= y_i^w
\end{alignat*}



\noindent
\textbf{Example on $DLEQ$ and why we need a random challenge}\\
We will show a concrete example why we need a challenge and it needs to be random. If the challenge is already known by the prover, for example  assume it is 1, then the prover can "prepare" and cheat with a wrong statement. 


\begin{enumerate}
    \item The prover sends $a_1=g^6$, $a_2=y_i^7$, $X_i=g^2$ and  $Y_i=y_i^3$ to verifier.
    \item The verifier creates a challenge \begin{math}C=1 \end{math} to prover.
    \item The prover computes \begin{math}r=w-p(i)  \cdot  C = 6-2  \cdot  1= 4\end{math} and sends $r$ to verifier.
    \item The verifier knows the following  $a_1=g^4  \cdot  X_i$ and $a_2=y_i^4  \cdot  Y_i$ and now he verifies:
    \begin{enumerate}        
        \item The verifier checks if:  \begin{math}a_1 = g^4 \cdot X_i^C = g^4 \cdot g^{2 \cdot 1} = g^6\end{math}
        \item The verifier checks if:  \begin{math} a_2=y_i^4  \cdot  Y_i^C = y_i^4  \cdot  y_i^{3 \cdot 1}= y_i^7 \end{math}
    \end{enumerate}
\end{enumerate}


\noindent
Even though the exponents are not the same, both checks passes, despite that the prover is dishonest. This shows that if there is no random challenge there wouldnt be soundness because the prover could cheat.\\

\noindent
\textbf{Example on $DLEQ$ with a random challenge which satisfies soundness}\\
Next example shows the verification with a random challenge.

\begin{enumerate}
    \item The prover sends $a_1=g^6$, $a_2=y_i^7$, $X_i=g^2$ and $Y_i=y_i^3$ to verifier.
    \item The verifier creates a challenge \begin{math}C=9\ (mod \ 5) \end{math} to prover.
    \item The prover computes \begin{math}r=w-p(i)  \cdot  C = 6-2  \cdot  4 \ (mod \ 5)= 3\end{math} and sends $r$ to verifier.
    \item The verifier knows the following  $a_1=g^3  \cdot  X_i$ and $a_2=y_i^3  \cdot  Y_i$ and now he verifies:
    \begin{enumerate}        
        \item The verifier checks if: \begin{math}a_1 = g^3 \cdot X_i^C = g^3 \cdot g^{2 \cdot 4} = g^3  \cdot  g^3 = g^6= g^1= g\end{math}
        \item The verifier checks if: \begin{math} a_2=y_i^3  \cdot  Y_i^C = y_i^3  \cdot  y_i^{3 \cdot 4}= y_i^3  \cdot  y_i^{12}= y_i^3  \cdot  y_i^2= y^5=y^0= 1 \end{math}
    \end{enumerate}
\end{enumerate}

\noindent
Note that soundness is fulfilled because the check doesn't pass because $a_1=g^6$ is different from $a_1=g$ and $a_2=y_i^7$ is different from $ a_2=y_i^0$. Recall that soundness is if the statement is false then it should fail with overwhelming probability.\\

\noindent
\textbf{The mathematical justification for soundness}\\
In the following we are showing that a prover will fail with overwhelming probability if he is dishonest which satisfies soundness. Since the verifier doesent know if the first step $X_i=g^{p(i)}$ and $Y_i=y_i^{p(i)}$ has been computed correctly. We denote these exponents by \begin{math}a_1=g^w\end{math}    and \begin{math}a_2=y_i^{w^{'}}\end{math} and \begin{math}X_i=g^{m_i}\end{math}    and \begin{math}Y_i=y_i^{m_i^{'}}\end{math}. We know \begin{math} a_1= g^w \end{math} is equal to \begin{math}g^r  \cdot  X_i^C=g^r \cdot g^{m_i \cdot C} = g^{r+m_i \cdot C}\end{math} and \begin{math} a_2= y_i^{w^{'}}\end{math} is equal to \begin{math}y_i^r  \cdot  Y_i^C=y_i^r \cdot y_i^{m_i^{'} \cdot C} = y_i^{r+m_i^{'} \cdot C}\end{math}. Based on this we can now write two inequalities. In order for these inequalities to be true we can rewrite.

\begin{alignat*}{5}
 a_1 &= g^w &&= g^r  \cdot  X_i^C &&=g^r \cdot g^{m_i \cdot C} &&= g^{r+m_i \cdot C}\\
 a_2 &= y_i^{w^{'}} &&= y_i^r  \cdot  Y_i^C &&=y_i^r \cdot y_i^{m_i^{'} \cdot C} &&= y_i^{r+m_i^{'} \cdot C}
\end{alignat*}

\noindent
We can now write two inequalities

\begin{alignat*}{5}
 w &= r+m_i  \cdot  C\ (mod\ q) &&\implies r &&= w-m_i \cdot C\ (mod\ q)\\
 w^{'} &= r+m_i^{'}  \cdot  C\ (mod\ q) &&\implies r &&= w^{'}-m_i^{'}  \cdot  C\ (mod\ q)
\end{alignat*}
\noindent
These two inequalities has to be equal, therefor we can rewrite

\begin{alignat*}{5}
w-m_i \cdot C = w^{'}-m_i^{'}\ (mod\ q) \implies (w-w^{'})-(m_i - m_i^{'})  \cdot  C = 0 \ (mod\ q) 
\end{alignat*}


\noindent
The prover has to be honest if this equation must be true. It is overwhelming unlikely that, if the prover has been dishonest, where $m_i \neq m_{i^{'}}$, that he will succeed. Since the $C$ is known afterwards the construction of $w$ and $w^{'}$ the probability will be \begin{math} \frac{1}{q}\end{math} for a convincing the verifier. Lets clarify with an example with a dishonest prover $C=5$, $(w-w^i)-(m_i - m_i^{'})=2$ and $q=5$. The dishonest prover will then succeed because $2 \cdot 5 = 0 \ (mod \ 5)$. Since the $q$ is a large number the dishonest prover should fail with overwhelming probability.\\


\noindent
\textbf{Zero knowledge}\\
The zero knowledge in this context means that the verifier doesn't learn anything about the $p(i)$. One way to argue zero knowledge is by showing that the values sent in the protocol doesn't depend on the $p(i)$. So if one can construct the values $a_1, \ a_2, \ r$  without knowing  $p(i)$  shows that they do not depend on $p(i)$ and we thereby do not learn anything about $p(i)$. One way of doing this is though experiment where on can change the order of the protocol. In is out of this thesis scope to go further depth on this subject.\\

 

%----------------------------------------------------------------------
\subsection{Description of $ \mathbf{PROOF_U} $} \label{sec:proof_u}
%----------------------------------------------------------------------
In this section we show with $PROOF_U$ that the voter either votes  1 or 0. This is achieved by the voter proving that there is consistency between the exponents of how \begin{math}U\end{math} and \begin{math}C_0\end{math} is constructed from \begin{math}U=G^{s+v}\end{math} and \begin{math}C_0 = g^s\end{math}. The exponents only vary when 1 or 0 is voted. We will show the interactive proof and through Fiat–Shamir  we transform an interactive proof of knowledge into a non-interactive proof of knowledge. The protocol illustration includes both scenarios where the voter votes either 0 or 1. If the voter votes 0 step 1a, 2, 3a, 4 will be followed. If the voter votes 1 step 1b, 2, 3b, 4 will be followed. An example of the proof is calculated in appendex \ref{sec:simple_review_of_calculation_of_proof_u_between_voter_and_verifier}.\\

\begin{figure}[H]
    \centering        
    
    $
    \begin{array}{l}
    \hline                      \
    \textbf{$PROOF_U$ protocol}      \\
    \hline                      \
    Public:  U=G^{s+v},\ C_0=g^s       \\
    \\
	\begin{array}{L{1.4cm}lcr}
        & \text{\textsf{Prover}} & \text{\textsf{Verifier}} \\
        \hline
        Step \ 1a   &           \begin{array}{l}
                                    if\ vote (v) = 0             \\ 
                                    w\in_R \{1,...,q-1\}, \\ 
                                    r_1\in_R\{1,...,q-1\},\\
                                    d_1\in_R\{1,...,q-1\},      \\ 
                                    a_0 = g^w,\\ 
                                    a_1 = g^{r_1} \cdot C^{d_1}_0,\\ 
                                    b_0 = G^w,  \\
                                    b_1 = G^{r_1}  \cdot  (\frac{U}{G^{1-v}})^{d_1} = G^{r_1}  \cdot  (\frac{U}{G})^{d_1} \\
                                \end{array}     &               & \\
                                \\
                    &                   \xrightarrow{\hspace{1em}a_0, a_1, b_0, b_1\hspace{1em}} \ \ {\scriptstyle  \textbf{Publish to bulletin}} &  & \\                                
                    &                   &               & \\
        Step \ 1b   &           \begin{array}{l}
                                    if\ vote (v) =1             \\ 
                                    w\in_R \{1,...,q-1\},\\ r_0\in_R\{1,...,q-1\},\\
                                    d_0\in_R\{1,...,q-1\},      \\ 
                                    a_0 = g^{r_0} \cdot C^{d_0}_0,\\
                                    a_1 = g^w,\\
                                    b_0 = G^{r_0}  \cdot  (\frac{U}{G^{1-v}})^{d_0}= G^{r_0}  \cdot  U^{d_0} ,\\
                                    b_1 = G^w\\
                                \end{array}     &               & \\
                    &                   &               & \\
                    \\
                    &                   \xrightarrow{\hspace{1em}a_0, a_1, b_0, b_1\hspace{1em}} \  {\scriptstyle  \textbf{Publish to bulletin}} & \\
        Step \ 2    &                    & \begin{array}{l}
                                {\scriptstyle  \textbf{Publish to bulletin}} \\      
                                C\in_R \{0,...,q-1\} \\ 
                                \xleftarrow{\hspace{2em}C\hspace{2em}}\\
                                \end{array}  \\
        Step \ 3a   &          \begin{array}{l}
                                   if\ vote (v) = 0             \\ 
                                   d_0= C-d_1\ mod\ q,\\
                                   r_0=w-s \cdot d_0 \ mod\ q\\  
                                \end{array}     &               & \\
                                \\
                    &                   \xrightarrow{\hspace{1em}d_0,\ r_0,\ d_1,\ r_1\hspace{1em}} \ \  {\scriptstyle  \textbf{Publish to bulletin}} &  & \\                                
                    &                   &               & \\
        Step \ 3b   &           \begin{array}{l}
                                    if\ vote (v) =1             \\ 
                                    d_1= C-d_0\ mod\ q, \\
                                    r_1=w-s \cdot d_1 \ mod\ q\\ 
                                \end{array}     &               & \\
                                \\
                    &                   \xrightarrow{\hspace{1em}d_0,\ r_0,\ d_1,\ r_1\hspace{1em}} \ \ {\scriptstyle  \textbf{Publish to bulletin}} &  &\\
                    &                   &               & \\
        Step \ 4   &                    & \begin{array}{l}
                                {\scriptstyle \textbf{Verification:}} \\        
                                C = d_1 + d_0,\\
                                a_0=g^{r_0}  \cdot  C^{d_0}_0,\\
                                b_0 = G^{r_0} \cdot U^{d_0},\\
                                a_1=g^{r_1}  \cdot  C^{d_1}_0,\\
                                b_1= G^{r_1}  \cdot (\frac{U}{G})^{d_1} \\ 
        \end{array} \\
        \hline
    \end{array}
    \end{array}
    $    
    \caption{$PROOF_U$}
	\label{fig:PROOF_U}
\end{figure}

\noindent
\textbf{Explanation of the protocol}\\
In step 1 the voter publish \begin{math}a_0,\ b_0,\ a_1,\ b_1\end{math}. Note that the difference between voting 0 or 1 is just by swapping the values between the variables \begin{math}a_0,\ b_0\end{math} and \begin{math}a_1,\ b_1\end{math}. The point is that the verifier will not be able to distinguish the value of the vote and thereby gain knowledge about the vote.



\begin{description}
    \item[Step 1:] Voter either votes $0$ or $1$:
                    \begin{enumerate}
                        \item  Voter votes 0 and creates: \begin{math}v=0,\ w\in_R \{1,...,q-1\},\ r_1\in_R\{1,...,q-1\},\ d_1\in_R\{1,...,q-1\}\end{math} and 
                                publish: \begin{math}a_0 = g^w,\ b_0 = G^w,\ a_1 = g^{r_1} \cdot C^{d_1}_0,\ b_1 = G^{r_1}  \cdot  (\frac{U}{G^{1-v}})^{d_1} = G^{r_1}  \cdot  (\frac{U}{G})^{d_1} \end{math}.
                        \item  Voter votes 1 and creates: \begin{math}v=1,\ w\in_R \{1,...,q-1\},\ r_0\in_R\{1,...,q-1\},\ d_0\in_R\{1,...,q-1\}\end{math} and publish: \begin{math}a_1 = g^w,\ b_1 = G^w,\ a_0 = g^{r_0} \cdot C^{d_0}_0,\ b_0 = G^{r_0}  \cdot  (\frac{U}{G^{1-v}})^{d_0}=  G^{r_0}  \cdot (\frac{U}{1})^{d_0}  =  G^{r_0}  \cdot  U^{d_0} \end{math}
                    \end{enumerate}

    

    
    \item[Step 2:] The verifier creates a challenge \begin{math}C\in_R \{0,...,q-1\}\end{math} to the voter.
    

    
    
    \item[Step 3:] The outcome from step 3 is that the voter publish \begin{math}d_0,\ r_0,\ d_1,\ r_1\end{math}. Note that the voters computation depends on the challenge from the interaction between the verifier. Voter either votes $0$ or $1$:
        \begin{enumerate}
            \item  Voter votes 0 computes: \begin{math}v=0,\ d_0= C-d_1\ mod\ q, \ r_0=w-s \cdot d_0 \ mod\ q\end{math}
            \item  Voter votes 1 computes: \begin{math}v=1,\ d_1= C-d_0\ mod\ q, \ r_1=w-s \cdot d_1 \ mod\ q\end{math}
        \end{enumerate}
    
        
    \item[Step 4:] In step 4 the verifier will be able computes and verify consistency.
    \begin{math}C = d_1 + d_0,\ a_0=g^{r_0}  \cdot  C^{d_1}_0,\ b_0 = G^{r_0} \cdot U^{d_0},\ a_1=g^{r_1}  \cdot  C^{d_1}_0,\ b_1= G^{r_1}  \cdot (\frac{U}{G})^{d_1}\end{math}
\end{description}

\noindent
We can turn this into a non-interactive proof by replacing step 2 with the voter using a hash function and thereby avoiding interaction with the verifier. The prover will then compute a hash of \begin{math}C=H(U,\ C_0,\ a_0,\ b_0,\ a_1,\ b_1) \end{math}. Because of time constraint we are not able to elaborate further on this optimization. \\




\noindent
\textbf{Mathematical justification for correctness}\\
In the following we derive the mathematical justification from step 4. Here we will replace with earlier expression from above and replace by the actual value of the vote. This means is that the math depends on the value of the vote.\\

\noindent
\textbf{Explanation of \begin{math}a_0=g^{r_0}  \cdot  C^{d_0}_0\end{math}}\\

\noindent
The voter votes 0 and we show that \begin{math}a_0= g^w \stackrel{?}{=} g^{r_0}  \cdot  C^{d_0}_0 \end{math} is well constructed
\begin{align*}
    a_0 &=g^{r_0}  \cdot  C^{d_0}_0     \\ 
        &= g^{w-sd_0} \cdot  g^{sd_0}   \\
        &= g^{w-sd_0+ sd_0}             \\
        &= g^w                          
\end{align*}
The voter votes 1 is trivial because \begin{math}a_0 \end{math}  is constructed from \begin{math}a_0=g^{r_0}  \cdot  C^{d_0}_0 \end{math}\\



\noindent
\textbf{Explanation of \begin{math}b_0 = G^{r_0} \cdot U^{d_0}\end{math}}\\

\noindent
The voter votes 0 and we show that \begin{math}b_0 =  G^w  \stackrel{?}{=} G^{r_0} \cdot U^{d_0} \end{math} is well constructed
\begin{align*}
    b_0 &= G^{r_0} \cdot U^{d_0}                    \\
        &= G^{w-sd_0} \cdot G^{(s+0) \cdot d_{0}}   \\
        &= G^{w-sd_0} \cdot G^{sd_{0}}              \\
        &= G^w                                          
\end{align*}
The voter votes 1 and we show that \begin{math}b_0 = G^{r_0} \cdot (\frac{U}{G^{1-1}})^{d_0} \stackrel{?}{=}  G^{r_0} \cdot U^{d_0} \end{math}
\begin{align*}
    b_0 &= G^{r_0} \cdot (\frac{U}{G^{1-v}})^{d_0}  \\
        &= G^{r_0} \cdot (\frac{U}{G^{0}})^{d_0}    \\
        &= G^{r_0} \cdot (\frac{U}{1})^{d_0}        \\
        &= G^{r_0} \cdot U^{d_0}  
\end{align*}



\noindent
\textbf{Explanation of \begin{math}a_1=g^{r_1}  \cdot  C^{d_1}_0\end{math}}\\

\noindent
The voter votes 1 and we show that \begin{math}a_1=g^w \stackrel{?}{=} g^{r_1}  \cdot  C^{d_1}_0 \end{math} is well constructed
\begin{align*}
    a_1 &= g^{r_1}  \cdot  C^{d_1}_0    \\
        &= g^{w-sd_1} \cdot  g^{sd_1}   \\
        &= g^{w-sd_1+ sd_1}             \\
        &= g^w
\end{align*}
The voter votes 0 is trivial because \begin{math}a_1 \end{math} is constructed from \begin{math}a_1=g^{r_1}  \cdot  C^{d_1}_0 \end{math}.\\


\noindent
\textbf{Explanation of \begin{math}b_1= G^{r_1}  \cdot (\frac{U}{G})^{d_1}\end{math}}\\

\noindent
The voter votes 1 and we show that \begin{math}b_1=   G^W \stackrel{?}{=} G^{r_1}  \cdot (\frac{U}{G})^{d_1} \end{math} is well constructed \begin{align*}
    b_1 &= G^{r_1}  \cdot (\frac{U}{G})^{d_1}                   \\
        &= G^{w-sd_1} \cdot (U \cdot G^{-1})^{d_1}              \\
        &= G^{w-sd_1} \cdot  (G^{s+1})^{d_0} \cdot G^{-d_1}     \\
        &= G^{w-sd_1} \cdot  G^{sd_0+d_0} \cdot G^{-d_1}        \\
        &= G^w
\end{align*}
The voter votes 0 and we show that  \begin{math}b_1= G^{r_1}  \cdot (\frac{U}{G})^{d_1}  \stackrel{?}{=}  G^{r_1}  \cdot (\frac{U}{G^{1-v}})^{d_1} \end{math} is well constructed
\begin{align*}
    b_1 &= G^{r_1}  \cdot (\frac{U}{G^{1-v}})^{d_1}             \\ 
        &= G^{r_1}  \cdot (\frac{U}{G^{1-0}})^{d_1}             \\
        &= G^{r_1}  \cdot (\frac{U}{G})^{d_1}
\end{align*}



\noindent
We will not go to depth in Soundness and Zero knowledge for $PROOF_U$. Here we will refer to another paper. \cite{Cramer1994}



